(in-package #:zed.shader-library)

(defun noise/cellular-weight-samples ((samples :vec4))
  (let ((samples (1- (* samples 2))))
    (- (* samples samples samples) (sign samples))))

(defun noise/cellular ((point :vec2)
                       (hash-fn (function (:vec2) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (jitter-window 0.25)
           (hash-x hash-y (funcall hash-fn cell))
           (grad-x (+ (* (noise/cellular-weight-samples hash-x) jitter-window)
                      (vec4 0 1 0 1)))
           (grad-y (+ (* (noise/cellular-weight-samples hash-y) jitter-window)
                      (vec4 0 0 1 1)))
           (dx (- (.x vec) grad-x))
           (dy (- (.y vec) grad-y))
           (d (+ (* dx dx) (* dy dy)))
           (d (vec4 (min (.xy d) (.zw d)) (.zw d))))
    (* (min (.x d) (.y d)) (/ 1.125))))

(defun noise/cellular ((point :vec2))
  (noise/cellular point (lambda ((x :vec2)) (hash/fast32-2-per-corner x))))

(defun noise/cellular-derivs ((point :vec2)
                              (hash-fn (function (:vec2) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (jitter-window 0.25)
           (hash-x hash-y (funcall hash-fn cell))
           (grad-x (+ (* (noise/cellular-weight-samples hash-x) jitter-window)
                      (vec4 0 1 0 1)))
           (grad-y (+ (* (noise/cellular-weight-samples hash-y) jitter-window)
                      (vec4 0 0 1 1)))
           (dx (- (.x vec) grad-x))
           (dy (- (.y vec) grad-y))
           (d (+ (* dx dx) (* dy dy)))
           (t1 (if (< (.x d) (.y d))
                   (vec3 (.x d) (.x dx) (.x dy))
                   (vec3 (.y d) (.y dx) (.y dy))))
           (t2 (if (< (.z d) (.w d))
                   (vec3 (.z d) (.z dx) (.z dy))
                   (vec3 (.w d) (.w dx) (.w dy)))))
    (* (if (< (.x t1) (.x t2)) t1 t2)
       (vec3 1 2 2)
       (/ 1.125))))

(defun noise/cellular-derivs ((point :vec2))
  (noise/cellular-derivs point (lambda ((x :vec2)) (hash/fast32-2-per-corner x))))

(defun noise/cellular-fast ((point :vec2)
                            (hash-fn (function (:vec2) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (jitter-window (vec3 0.4 -0.4 0.6))
           (hash-x hash-y (funcall hash-fn cell))
           (grad-x (+ (* hash-x (.x jitter-window) 2) (.yzyz jitter-window)))
           (grad-y (+ (* hash-y (.x jitter-window) 2) (.yyzz jitter-window)))
           (dx (- (.x vec) grad-x))
           (dy (- (.y vec) grad-y))
           (d (+ (* dx dx) (* dy dy)))
           (d (vec4 (min (.xy d) (.zw d)) (.zw d))))
    (* (min (.x d) (.y d)) (/ 1.125))))

(defun noise/cellular-fast ((point :vec2))
  (noise/cellular-fast point (lambda ((x :vec2)) (hash/fast32-2-per-corner x))))

(defun noise/cellular ((point :vec3)
                       (hash-fn
                        (function (:vec3)
                         (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (jitter-window (/ 6.0))
           (hash-x0 hash-y0 hash-z0 hash-x1 hash-y1 hash-z1
                    (funcall hash-fn cell))
           (hash-x0 (+ (* (noise/cellular-weight-samples hash-x0) jitter-window)
                       (vec4 0 1 0 1)))
           (hash-y0 (+ (* (noise/cellular-weight-samples hash-y0) jitter-window)
                       (vec4 0 0 1 1)))
           (hash-z0 (* (noise/cellular-weight-samples hash-z0) jitter-window))
           (hash-x1 (+ (* (noise/cellular-weight-samples hash-x1) jitter-window)
                       (vec4 0 1 0 1)))
           (hash-y1 (+ (* (noise/cellular-weight-samples hash-y1) jitter-window)
                       (vec4 0 0 1 1)))
           (hash-z1 (+ (* (noise/cellular-weight-samples hash-z1) jitter-window) 1))
           (dx1 (- (.x vec) hash-x0))
           (dy1 (- (.y vec) hash-y0))
           (dz1 (- (.z vec) hash-z0))
           (dx2 (- (.x vec) hash-x1))
           (dy2 (- (.y vec) hash-y1))
           (dz2 (- (.z vec) hash-z1))
           (d2 (+ (* dx2 dx2) (* dy2 dy2) (* dz2 dz2)))
           (d1 (min (+ (* dx1 dx1) (* dy1 dy1) (* dz1 dz1)) d2))
           (d1 (min (.xy d1) (.wz d1))))
    (* (min (.x d1) (.y d1)) 0.75)))

(defun noise/cellular ((point :vec3))
  (noise/cellular point (lambda ((x :vec3)) (hash/fast32-3-per-corner x))))

(defun noise/cellular-derivs ((point :vec3)
                              (hash-fn
                               (function
                                (:vec3)
                                (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (jitter-window 0.16666667)
           (hash-x0 hash-y0 hash-z0 hash-x1 hash-y1 hash-z1
                    (funcall hash-fn cell))
           (hash-x0 (+ (* (noise/cellular-weight-samples hash-x0) jitter-window)
                       (vec4 0 1 0 1)))
           (hash-y0 (+ (* (noise/cellular-weight-samples hash-y0) jitter-window)
                       (vec4 0 0 1 1)))
           (hash-z0 (+ (* (noise/cellular-weight-samples hash-z0) jitter-window)
                       (vec4 0)))
           (hash-x1 (+ (* (noise/cellular-weight-samples hash-x1) jitter-window)
                       (vec4 0 1 0 1)))
           (hash-y1 (+ (* (noise/cellular-weight-samples hash-y1) jitter-window)
                       (vec4 0 0 1 1)))
           (hash-z1 (+ (* (noise/cellular-weight-samples hash-z1) jitter-window)
                       (vec4 1)))
           (dx1 (- (.x vec) hash-x0))
           (dy1 (- (.y vec) hash-y0))
           (dz1 (- (.z vec) hash-z0))
           (dx2 (- (.x vec) hash-x1))
           (dy2 (- (.y vec) hash-y1))
           (dz2 (- (.z vec) hash-z1))
           (d1 (+ (* dx1 dx1) (* dy1 dy1) (* dz1 dz1)))
           (d2 (+ (* dx2 dx2) (* dy2 dy2) (* dz2 dz2)))
           (r1 (if (< (.x d1) (.y d1))
                   (vec4 (.x d1) (.x dx1) (.x dy1) (.x dz1))
                   (vec4 (.y d1) (.y dx1) (.y dy1) (.y dz1))))
           (r2 (if (< (.z d1) (.w d1))
                   (vec4 (.z d1) (.z dx1) (.z dy1) (.z dz1))
                   (vec4 (.w d1) (.w dx1) (.w dy1) (.w dz1))))
           (r3 (if (< (.x d2) (.y d2))
                   (vec4 (.x d2) (.x dx2) (.x dy2) (.x dz2))
                   (vec4 (.y d2) (.y dx2) (.y dy2) (.y dz2))))
           (r4 (if (< (.z d2) (.w d2))
                   (vec4 (.z d2) (.z dx2) (.z dy2) (.z dz2))
                   (vec4 (.w d2) (.w dx2) (.w dy2) (.w dz2))))
           (t1 (if (< (.x r1) (.x r2)) r1 r2))
           (t2 (if (< (.x r3) (.x r4)) r3 r4)))
    (* (if (< (.x t1) (.x t2)) t1 t2)
       (vec4 1 2 2 2)
       0.75)))

(defun noise/cellular-derivs ((point :vec3))
  (noise/cellular-derivs point (lambda ((x :vec3)) (hash/fast32-3-per-corner x))))

(defun noise/cellular-fast ((point :vec3)
                            (hash-fn
                             (function
                              (:vec3)
                              (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (jitter-window (vec3 0.4 -0.4 0.6))
           (hash-x0 hash-y0 hash-z0 hash-x1 hash-y1 hash-z1
                    (funcall hash-fn cell))
           (hash-x0 (+ (* hash-x0 (.x jitter-window) 2) (.yzyz jitter-window)))
           (hash-y0 (+ (* hash-y0 (.x jitter-window) 2) (.yyzz jitter-window)))
           (hash-z0 (+ (* hash-z0 (.x jitter-window) 2) (.y jitter-window)))
           (hash-x1 (+ (* hash-x1 (.x jitter-window) 2) (.yzyz jitter-window)))
           (hash-y1 (+ (* hash-y1 (.x jitter-window) 2) (.yyzz jitter-window)))
           (hash-z1 (+ (* hash-z1 (.x jitter-window) 2) (.z jitter-window)))
           (dx1 (- (.x vec) hash-x0))
           (dy1 (- (.y vec) hash-y0))
           (dz1 (- (.z vec) hash-z0))
           (dx2 (- (.x vec) hash-x1))
           (dy2 (- (.y vec) hash-y1))
           (dz2 (- (.z vec) hash-z1))
           (d2 (+ (* dx2 dx2) (* dy2 dy2) (* dz2 dz2)))
           (d1 (min (+ (* dx1 dx1) (* dy1 dy1) (* dz1 dz1)) d2))
           (d1 (min (.xy d1) (.wz d1)) ))
    (* (min (.x d1) (.y d1)) (/ 9 12.0))))

(defun noise/cellular-fast ((point :vec3))
  (noise/cellular-fast point (lambda ((x :vec3)) (hash/fast32-3-per-corner x))))

(defun noise/hermite ((point :vec2)
                      (hash-fn (function (:vec2) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (hash-x hash-y (funcall hash-fn cell))
           (hash-x (- hash-x 0.5 +epsilon+))
           (hash-y (- hash-y 0.5 +epsilon+))
           (norm (inversesqrt (+ (* hash-x hash-x) (* hash-y hash-y))))
           (hash-x (* hash-x norm))
           (hash-y (* hash-y norm))
           (out (shape/quintic-hermite
                 (.y vec) (.xy hash-x) (.zw hash-x) (.xy hash-y) (.zw hash-y)))
           (out (* (shape/quintic-hermite
                    (.x vec) (.x out) (.y out) (.z out) (.w out))
                   2.2627418)))
    (map-domain out -1 1 0 1)))

(defun noise/hermite ((point :vec2))
  (noise/hermite point (lambda ((x :vec2)) (hash/fast32-2-per-corner x))))

(defun noise/hermite-derivs ((point :vec2)
                             (hash-fn (function (:vec2) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (hash-x hash-y (funcall hash-fn cell))
           (grad-x (- hash-x 0.5 +epsilon+))
           (grad-y (- hash-y 0.5 +epsilon+))
           (norm (inversesqrt (+ (* grad-x grad-x) (* grad-y grad-y))))
           (grad-x (* grad-x norm))
           (grad-y (* grad-y norm))
           (temp-x (shape/quintic-hermite
                    (.y vec) (.xy grad-x) (.zw grad-x) (.xy grad-y)
                    (.zw grad-y)))
           (temp-y (shape/quintic-hermite
                    (.x vec) (.xz grad-y) (.yw grad-y) (.xz grad-x)
                    (.yw grad-x)))
           (noise (shape/quintic-hermite
                   (.x vec) (.x temp-x) (.y temp-x) (.z temp-x) (.w temp-x)))
           (noise (map-domain noise -0.4419417 0.4419417 0 1))
           (derivs (* (vec2 (shape/quintic-hermite-derivative
                             (.x vec) (.x temp-x) (.y temp-x) (.z temp-x)
                             (.w temp-x))
                            (shape/quintic-hermite-derivative
                             (.y vec) (.x temp-y) (.y temp-y) (.z temp-y)
                             (.w temp-y)))
                      1.1313709)))
    (vec3 noise derivs)))

(defun noise/hermite-derivs ((point :vec2))
  (noise/hermite-derivs point (lambda ((x :vec2)) (hash/fast32-2-per-corner x))))

(defun noise/hermite ((point :vec3)
                      (hash-fn
                       (function (:vec3)
                        (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (hash-x0 hash-y0 hash-z0 hash-x1 hash-y1 hash-z1
                    (funcall hash-fn cell))
           (hash-x0 (- hash-x0 0.5 +epsilon+))
           (hash-y0 (- hash-y0 0.5 +epsilon+))
           (hash-z0 (- hash-z0 0.5 +epsilon+))
           (hash-x1 (- hash-x1 0.5 +epsilon+))
           (hash-y1 (- hash-y1 0.5 +epsilon+))
           (hash-z1 (- hash-z1 0.5 +epsilon+))
           (norm0 (inversesqrt (+ (* hash-x0 hash-x0) (* hash-y0 hash-y0)
                                  (* hash-z0 hash-z0))))
           (norm1 (inversesqrt (+ (* hash-x1 hash-x1) (* hash-y1 hash-y1)
                                  (* hash-z1 hash-z1))))
           (grad-x0 (* hash-x0 norm0))
           (grad-y0 (* hash-y0 norm0))
           (grad-z0 (* hash-z0 norm0))
           (grad-x1 (* hash-x1 norm1))
           (grad-y1 (* hash-y1 norm1))
           (grad-z1 (* hash-z1 norm1))
           (ival igrad-x igrad-y (shape/quintic-hermite
                                  (.z vec) grad-x0 grad-x1 grad-y0 grad-y1
                                  grad-z0 grad-z1))
           (out (shape/quintic-hermite
                 (.y vec)
                 (vec4 (.xy ival) (.xy igrad-x))
                 (vec4 (.zw ival) (.zw igrad-x))
                 (vec4 (.xy igrad-y) 0 0)
                 (vec4 (.zw igrad-y) 0 0)))
           (out (* (shape/quintic-hermite
                    (.x vec) (.x out) (.y out) (.z out) (.w out))
                   1.8475208)))
    (map-domain out -1 1 0 1)))

(defun noise/hermite ((point :vec3))
  (noise/hermite point (lambda ((x :vec3)) (hash/fast32-3-per-corner x))))

(defun noise/hermite-derivs ((point :vec3)
                             (hash-fn
                              (function
                               (:vec3)
                               (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (hash-x0 hash-y0 hash-z0 hash-x1 hash-y1 hash-z1
                    (funcall hash-fn cell))
           (grad-x0 (- hash-x0 0.5 +epsilon+))
           (grad-y0 (- hash-y0 0.5 +epsilon+))
           (grad-z0 (- hash-z0 0.5 +epsilon+))
           (grad-x1 (- hash-x1 0.5 +epsilon+))
           (grad-y1 (- hash-y1 0.5 +epsilon+))
           (grad-z1 (- hash-z1 0.5 +epsilon+))
           (norm0 (inversesqrt (+ (* grad-x0 grad-x0) (* grad-y0 grad-y0)
                                  (* grad-z0 grad-z0))))
           (norm1 (inversesqrt (+ (* grad-x1 grad-x1) (* grad-y1 grad-y1)
                                  (* grad-z1 grad-z1))))
           (grad-x0 (* grad-x0 norm0))
           (grad-y0 (* grad-y0 norm0))
           (grad-z0 (* grad-z0 norm0))
           (grad-x1 (* grad-x1 norm1))
           (grad-y1 (* grad-y1 norm1))
           (grad-z1 (* grad-z1 norm1))
           (ival-z igrad-xz igrad-yz (shape/quintic-hermite
                                      (.z vec) grad-x0 grad-x1 grad-y0 grad-y1
                                      grad-z0 grad-z1))
           (ival-y igrad-xy igrad-zy (shape/quintic-hermite
                                      (.y vec)
                                      (vec4 (.xy grad-x0) (.xy grad-x1))
                                      (vec4 (.zw grad-x0) (.zw grad-x1))
                                      (vec4 (.xy grad-z0) (.xy grad-z1))
                                      (vec4 (.zw grad-z0) (.zw grad-z1))
                                      (vec4 (.xy grad-y0) (.xy grad-y1))
                                      (vec4 (.zw grad-y0) (.zw grad-y1))))
           (temp-x (shape/quintic-hermite
                    (.y vec)
                    (vec4 (.xy ival-z) (.xy igrad-xz))
                    (vec4 (.zw ival-z) (.zw igrad-xz))
                    (vec4 (.xy igrad-yz) 0 0)
                    (vec4 (.zw igrad-yz) 0 0)))
           (temp-y (shape/quintic-hermite
                    (.x vec)
                    (vec4 (.xz ival-z) (.xz igrad-yz))
                    (vec4 (.yw ival-z) (.yw igrad-yz))
                    (vec4 (.xz igrad-xz) 0 0)
                    (vec4 (.yw igrad-xz) 0 0)))
           (temp-z (shape/quintic-hermite
                    (.x vec)
                    (vec4 (.xz ival-y) (.xz igrad-zy))
                    (vec4 (.yw ival-y) (.yw igrad-zy))
                    (vec4 (.xz igrad-xy) 0 0)
                    (vec4 (.yw igrad-xy) 0 0)))
           (noise (shape/quintic-hermite
                   (.x vec) (.x temp-x) (.y temp-x) (.z temp-x) (.w temp-x)))
           (noise (map-domain noise -0.5412659 0.5412659 0 1))
           (derivs (* (vec3 (shape/quintic-hermite-derivative
                             (.x vec) (.x temp-x) (.y temp-x) (.z temp-x)
                             (.w temp-x))
                            (shape/quintic-hermite-derivative
                             (.y vec) (.x temp-y) (.y temp-y) (.z temp-y)
                             (.w temp-y))
                            (shape/quintic-hermite-derivative
                             (.z vec) (.x temp-z) (.y temp-z) (.z temp-z)
                             (.w temp-z)))
                      0.92376035)))
    (vec4 noise derivs)))

(defun noise/hermite-derivs ((point :vec3))
  (noise/hermite-derivs point (lambda ((x :vec3)) (hash/fast32-3-per-corner x))))

(defun noise/perlin ((point :vec2)
                     (hash-fn (function (:vec2) (:vec4 :vec4))))
  (mvlet* ((origin (floor point))
           (vecs (- (.xyxy point) (vec4 origin (1+ origin))))
           (hash-x hash-y (funcall hash-fn origin))
           (grad-x (- hash-x 0.5 +epsilon+))
           (grad-y (- hash-y 0.5 +epsilon+))
           (blend (shape/quintic-curve (.xy vecs)))
           (blend (vec4 blend (- 1 blend)))
           (out (dot (* (inversesqrt (+ (* grad-x grad-x) (* grad-y grad-y)))
                        (+ (* grad-x (.xzxz vecs)) (* grad-y (.yyww vecs)))
                        1.4142135)
                     (* (.zxzx blend) (.wwyy blend)))))
    (map-domain out -1 1 0 1)))

(defun noise/perlin ((point :vec2))
  (noise/perlin point (lambda ((x :vec2)) (hash/fast32-2-per-corner x))))

(defun noise/perlin-derivs ((point :vec2)
                            (hash-fn (function (:vec2) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vecs (- (.xyxy point) (vec4 cell (1+ cell))))
           (hash-x hash-y (funcall hash-fn cell))
           (grad-x (- hash-x 0.5 +epsilon+))
           (grad-y (- hash-y 0.5 +epsilon+))
           (norm (inversesqrt (+ (* grad-x grad-x) (* grad-y grad-y))))
           (grad-x (* grad-x norm))
           (grad-y (* grad-y norm))
           (dotval (+ (* grad-x (.xzxz vecs)) (* grad-y (.yyww vecs))))
           (dotval0-grad0 (vec3 (.x dotval) (.x grad-x) (.x grad-y)))
           (dotval1-grad1 (vec3 (.y dotval) (.y grad-x) (.y grad-y)))
           (dotval2-grad2 (vec3 (.z dotval) (.z grad-x) (.z grad-y)))
           (dotval3-grad3 (vec3 (.w dotval) (.w grad-x) (.w grad-y)))
           (k0-gk0 (- dotval1-grad1 dotval0-grad0))
           (k1-gk1 (- dotval2-grad2 dotval0-grad0))
           (k2-gk2 (- dotval3-grad3 dotval2-grad2 k0-gk0))
           (blend (shape/quintic-curve-interpolate-derivative
                   (.xy vecs)))
           (out (+ dotval0-grad0
                   (* (.x blend) k0-gk0)
                   (* (.y blend) (+ k1-gk1 (* (.x blend) k2-gk2)))))
           (noise (map-domain (.x out) -0.70710677 0.70710677 0 1))
           (derivs (* (+ (.yz out) (+ (* (.zw blend)
                                         (vec2 (.x k0-gk0) (.x k1-gk1)))
                                      (* (.yx blend) (.xx k2-gk2))))
                      0.70710677)))
    (vec3 noise derivs)))

(defun noise/perlin-derivs ((point :vec2))
  (noise/perlin-derivs point (lambda ((x :vec2)) (hash/fast32-2-per-corner x))))

(defun noise/perlin-surflet ((point :vec2)
                             (hash-fn (function (:vec2) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vecs (- (.xyxy point) (vec4 cell (1+ cell))))
           (hash-x hash-y (funcall hash-fn cell))
           (grad-x (- hash-x 0.5 +epsilon+))
           (grad-y (- hash-y 0.5 +epsilon+))
           (vecs-squared (* vecs vecs))
           (vecs-squared (+ (.xzxz vecs-squared) (.yyww vecs-squared)))
           (out (dot (shape/falloff-squared-c2
                      (min (vec4 1) vecs-squared))
                     (* (inversesqrt (+ (* grad-x grad-x) (* grad-y grad-y)))
                        (+ (* grad-x (.xzxz vecs)) (* grad-y (.yyww vecs)))
                        2.3703704))))
    (map-domain out -1 1 0 1)))

(defun noise/perlin-surflet ((point :vec2))
  (noise/perlin-surflet point (lambda ((x :vec2)) (hash/fast32-2-per-corner x))))

(defun noise/perlin-surflet-derivs ((point :vec2)
                                    (hash-fn
                                     (function (:vec2)
                                      (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vecs (- (.xyxy point) (vec4 cell (1+ cell))))
           (hash-x hash-y (funcall hash-fn cell))
           (grad-x (- hash-x 0.5 +epsilon+))
           (grad-y (- hash-y 0.5 +epsilon+))
           (norm (inversesqrt (+ (* grad-x grad-x) (* grad-y grad-y))))
           (grad-x (* grad-x norm))
           (grad-y (* grad-y norm))
           (vecs-squared (* vecs vecs))
           (m (max (- 1 (+ (.xzxz vecs-squared) (.yyww vecs-squared))) 0))
           (m2 (* m m))
           (m3 (* m m2))
           (out (dot m3 (+ (* grad-x (.xzxz vecs)) (* grad-y (.yyww vecs)))))
           (temp (* -6 m2 out))
           (noise (map-domain out -0.421875 0.421875 0 1))
           (derivs (* (vec2 (* (dot temp (.xzxz vecs)) (dot m3 grad-x))
                            (* (dot temp (.yyww vecs)) (dot m3 grad-y)))
                      1.1851852)))
    (vec3 noise derivs)))

(defun noise/perlin-surflet-derivs ((point :vec2))
  (noise/perlin-surflet-derivs point (lambda ((x :vec2)) (hash/fast32-2-per-corner x))))

(defun noise/perlin-improved ((point :vec2)
                              (hash-fn (function (:vec2) :vec4)))
  (let* ((cell (floor point))
         (vecs (- (.xyxy point) (vec4 cell (1+ cell))))
         (hash (- (funcall hash-fn cell) 0.5))
         (blend (shape/quintic-curve (.xy vecs)))
         (blend (vec4 blend (- 1 blend)))
         (out (dot (+ (* (.xzxz vecs) (sign hash))
                      (* (.yyww vecs) (sign (- (abs hash) 0.25))))
                   (* (.zxzx blend) (.wwyy blend)))))
    (map-domain out -1 1 0 1)))

(defun noise/perlin-improved ((point :vec2))
  (perlin-improved point (lambda ((x :vec2)) (hash/fast32 x))))

(defun noise/perlin ((point :vec3)
                     (hash-fn
                      (function (:vec3)
                       (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (vec-1 (1- vec))
           (hash-x0 hash-y0 hash-z0 hash-x1 hash-y1 hash-z1
                    (funcall hash-fn cell))
           (grad-x0 (- hash-x0 0.5 +epsilon+))
           (grad-y0 (- hash-y0 0.5 +epsilon+))
           (grad-z0 (- hash-z0 0.5 +epsilon+))
           (grad-x1 (- hash-x1 0.5 +epsilon+))
           (grad-y1 (- hash-y1 0.5 +epsilon+))
           (grad-z1 (- hash-z1 0.5 +epsilon+))
           (temp1 (* (inversesqrt (+ (* grad-x0 grad-x0) (* grad-y0 grad-y0)
                                     (* grad-z0 grad-z0)))
                     (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x0)
                        (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y0)
                        (* (.z vec) grad-z0))))
           (temp2 (* (inversesqrt (+ (* grad-x1 grad-x1) (* grad-y1 grad-y1)
                                     (* grad-z1 grad-z1)))
                     (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x1)
                        (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y1)
                        (* (.z vec-1) grad-z1))))
           (blend (shape/quintic-curve vec))
           (out (mix temp1 temp2 (.z blend)))
           (blend (vec4 (.xy blend) (- 1 (.xy blend))))
           (out (* (dot out (* (.zxzx blend) (.wwyy blend))) 1.1547005)))
    (map-domain out -1 1 0 1)))

(defun noise/perlin ((point :vec3))
  (noise/perlin point (lambda ((x :vec3)) (hash/fast32-3-per-corner x))))

(defun noise/perlin-derivs ((point :vec3)
                            (hash-fn
                             (function
                              (:vec3)
                              (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (vec-1 (1- vec))
           (hash-x0 hash-y0 hash-z0 hash-x1 hash-y1 hash-z1
                    (funcall hash-fn cell))
           (grad-x0 (- hash-x0 0.5 +epsilon+))
           (grad-y0 (- hash-y0 0.5 +epsilon+))
           (grad-z0 (- hash-z0 0.5 +epsilon+))
           (grad-x1 (- hash-x1 0.5 +epsilon+))
           (grad-y1 (- hash-y1 0.5 +epsilon+))
           (grad-z1 (- hash-z1 0.5 +epsilon+))
           (norm0 (inversesqrt (+ (* grad-x0 grad-x0) (* grad-y0 grad-y0)
                                  (* grad-z0 grad-z0))))
           (norm1 (inversesqrt (+ (* grad-x1 grad-x1) (* grad-y1 grad-y1)
                                  (* grad-z1 grad-z1))))
           (grad-x0 (* grad-x0 norm0))
           (grad-y0 (* grad-y0 norm0))
           (grad-z0 (* grad-z0 norm0))
           (grad-x1 (* grad-x1 norm1))
           (grad-y1 (* grad-y1 norm1))
           (grad-z1 (* grad-z1 norm1))
           (dot0 (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x0)
                    (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y0)
                    (* (.z vec) grad-z0)))
           (dot1 (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x1)
                    (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y1)
                    (* (.z vec-1) grad-z1)))
           (dot0-grad0 (vec4 (.x dot0) (.x grad-x0) (.x grad-y0) (.x grad-z0)))
           (dot1-grad1 (vec4 (.y dot0) (.y grad-x0) (.y grad-y0) (.y grad-z0)))
           (dot2-grad2 (vec4 (.z dot0) (.z grad-x0) (.z grad-y0) (.z grad-z0)))
           (dot3-grad3 (vec4 (.w dot0) (.w grad-x0) (.w grad-y0) (.w grad-z0)))
           (dot4-grad4 (vec4 (.x dot1) (.x grad-x1) (.x grad-y1) (.x grad-z1)))
           (dot5-grad5 (vec4 (.y dot1) (.y grad-x1) (.y grad-y1) (.y grad-z1)))
           (dot6-grad6 (vec4 (.z dot1) (.z grad-x1) (.z grad-y1) (.z grad-z1)))
           (dot7-grad7 (vec4 (.w dot1) (.w grad-x1) (.w grad-y1) (.w grad-z1)))
           (k0-gk0 (- dot1-grad1 dot0-grad0))
           (k1-gk1 (- dot2-grad2 dot0-grad0))
           (k2-gk2 (- dot4-grad4 dot0-grad0))
           (k3-gk3 (- dot3-grad3 dot2-grad2 k0-gk0))
           (k4-gk4 (- dot5-grad5 dot4-grad4 k0-gk0))
           (k5-gk5 (- dot6-grad6 dot4-grad4 k1-gk1))
           (k6-gk6 (- (- dot7-grad7 dot6-grad6) (- dot5-grad5 dot4-grad4)
                      k3-gk3))
           (blend (shape/quintic-curve vec))
           (blend-deriv (shape/quintic-curve-derivative vec))
           (out (+ dot0-grad0
                   (* (.x blend) (+ k0-gk0 (* (.y blend) k3-gk3)))
                   (* (.y blend) (+ k1-gk1 (* (.z blend) k5-gk5)))
                   (* (.z blend) (+ k2-gk2 (* (.x blend)
                                              (+ k4-gk4
                                                 (* (.y blend) k6-gk6)))))))
           (noise (map-domain (.x out) -0.8660254 0.8660254 0 1))
           (derivs (* (vec3 (+ (.y out)
                               (dot (vec4 (.x k0-gk0)
                                          (* (.x k3-gk3) (.y blend))
                                          (* (vec2 (.x k4-gk4)
                                                   (* (.x k6-gk6) (.y blend)))
                                             (.z blend)))
                                    (vec4 (.x blend-deriv))))
                            (+ (.z out)
                               (dot (vec4 (.x k1-gk1)
                                          (* (.x k3-gk3) (.x blend))
                                          (* (vec2 (.x k5-gk5)
                                                   (* (.x k6-gk6) (.x blend)))
                                             (.z blend)))
                                    (vec4 (.y blend-deriv))))
                            (+ (.w out)
                               (dot (vec4 (.x k2-gk2)
                                          (* (.x k4-gk4) (.x blend))
                                          (* (vec2 (.x k5-gk5)
                                                   (* (.x k6-gk6) (.x blend)))
                                             (.y blend)))
                                    (vec4 (.x blend-deriv)))))
                      0.57735026)))
    (vec4 noise derivs)))

(defun noise/perlin-derivs ((point :vec3))
  (noise/perlin-derivs point (lambda ((x :vec3)) (hash/fast32-3-per-corner x))))

(defun noise/perlin-surflet ((point :vec3)
                             (hash-fn
                              (function
                               (:vec3)
                               (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (vec-1 (1- vec))
           (hash-x0 hash-y0 hash-z0 hash-x1 hash-y1 hash-z1
                    (funcall hash-fn cell))
           (grad-x0 (- hash-x0 0.5 +epsilon+))
           (grad-y0 (- hash-y0 0.5 +epsilon+))
           (grad-z0 (- hash-z0 0.5 +epsilon+))
           (grad-x1 (- hash-x1 0.5 +epsilon+))
           (grad-y1 (- hash-y1 0.5 +epsilon+))
           (grad-z1 (- hash-z1 0.5 +epsilon+))
           (temp1 (* (inversesqrt (+ (* grad-x0 grad-x0) (* grad-y0 grad-y0)
                                     (* grad-z0 grad-z0)))
                     (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x0)
                        (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y0)
                        (* (.z vec) grad-z0))))
           (temp2 (* (inversesqrt (+ (* grad-x1 grad-x1) (* grad-y1 grad-y1)
                                     (* grad-z1 grad-z1)))
                     (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x1)
                        (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y1)
                        (* (.z vec-1) grad-z1))))
           (vec (* vec vec))
           (vec-1 (* vec-1 vec-1))
           (vecs-squared (+ (vec4 (.x vec) (.x vec-1) (.x vec) (.x vec-1))
                            (vec4 (.yy vec) (.yy vec-1))))
           (out (* (+ (dot (shape/falloff-squared-c2
                            (min (vec4 1) (+ vecs-squared (.z vec))))
                           temp1)
                      (dot (shape/falloff-squared-c2
                            (min (vec4 1) (+ vecs-squared (.z vec-1))))
                           temp2))
                   2.3703704)))
    (map-domain out -1 1 0 1)))

(defun noise/perlin-surflet ((point :vec3))
  (noise/perlin-surflet point (lambda ((x :vec3)) (hash/fast32-3-per-corner x))))

(defun noise/perlin-surflet-derivs ((point :vec3)
                                    (hash-fn
                                     (function
                                      (:vec3)
                                      (:vec4 :vec4 :vec4 :vec4 :vec4
                                             :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (vec-1 (1- vec))
           (hash-x0 hash-y0 hash-z0 hash-x1 hash-y1 hash-z1
                    (funcall hash-fn cell))
           (grad-x0 (- hash-x0 0.5 +epsilon+))
           (grad-y0 (- hash-y0 0.5 +epsilon+))
           (grad-z0 (- hash-z0 0.5 +epsilon+))
           (grad-x1 (- hash-x1 0.5 +epsilon+))
           (grad-y1 (- hash-y1 0.5 +epsilon+))
           (grad-z1 (- hash-z1 0.5 +epsilon+))
           (norm0 (inversesqrt (+ (* grad-x0 grad-x0) (* grad-y0 grad-y0)
                                  (* grad-z0 grad-z0))))
           (norm1 (inversesqrt (+ (* grad-x1 grad-x1) (* grad-y1 grad-y1)
                                  (* grad-z1 grad-z1))))
           (grad-x0 (* grad-x0 norm0))
           (grad-y0 (* grad-y0 norm0))
           (grad-z0 (* grad-z0 norm0))
           (grad-x1 (* grad-x1 norm1))
           (grad-y1 (* grad-y1 norm1))
           (grad-z1 (* grad-z1 norm1))
           (grad-results0 (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x0)
                             (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y0)
                             (* (.z vec) grad-z0)))
           (grad-results1 (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x1)
                             (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y1)
                             (* (.z vec-1) grad-z1)))
           (vec-squared (* vec vec))
           (vec-1-squared (* vec-1 vec-1))
           (vecs-squared (+ (.xyxy (vec2 (.x vec-squared) (.x vec-1-squared)))
                            (.xxyy (vec2 (.y vec-squared) (.y vec-1-squared)))))
           (m-0 (max (- 1 (+ vecs-squared (.z vec-squared))) 0))
           (m2-0 (* m-0 m-0))
           (m3-0 (* m-0 m2-0))
           (m-1 (max (- 1 (+ vecs-squared (.z vec-1-squared))) 0))
           (m2-1 (* m-1 m-1))
           (m3-1 (* m-1 m2-1))
           (temp0 (* -6 m2-0 grad-results0))
           (temp1 (* -6 m2-1 grad-results1))
           (deriv0 (vec3 (+ (dot temp0 (.xyxy (vec2 (.x vec) (.x vec-1))))
                            (dot m3-0 grad-x0))
                         (+ (dot temp0 (.xxyy (vec2 (.y vec) (.y vec-1))))
                            (dot m3-0 grad-y0))
                         (+ (dot temp0 (.zzzz vec)) (dot m3-0 grad-z0))))
           (deriv1 (vec3 (+ (dot temp1 (.xyxy (vec2 (.x vec) (.x vec-1))))
                            (dot m3-1 grad-x1))
                         (+ (dot temp1 (.xxyy (vec2 (.y vec) (.y vec-1))))
                            (dot m3-1 grad-y1))
                         (+ (dot temp1 (.zzzz vec-1)) (dot m3-1 grad-z1))))
           (noise (+ (dot m3-0 grad-results0)
                     (dot m3-1 grad-results1)))
           (noise (map-domain noise -0.421875 0.421875 0 1))
           (derivs (* (+ deriv0 deriv1) 1.1851852)))
    (vec4 noise derivs)))

(defun noise/perlin-surflet-derivs ((point :vec3))
  (noise/perlin-surflet-derivs point (lambda ((x :vec3)) (hash/fast32-3-per-corner x))))

(defun noise/perlin-improved ((point :vec3)
                              (hash-fn (function (:vec3) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (vec-1 (1- vec))
           (hash-low-z hash-high-z (funcall hash-fn cell))
           (hash-low-z (- hash-low-z 0.5))
           (hash-high-z (- hash-high-z 0.5))
           (grad-00 (* (.xyxy (vec2 (.x vec) (.x vec-1))) (sign hash-low-z)))
           (hash-low-z (- (abs hash-low-z) 0.25))
           (grad-01 (* (.xxyy (vec2 (.y vec) (.y vec-1))) (sign hash-low-z)))
           (grad-02 (* (.z vec) (sign (- (abs hash-low-z) 0.125))))
           (grad-10 (* (.xyxy (vec2 (.x vec) (.x vec-1))) (sign hash-high-z)))
           (hash-high-z (- (abs hash-high-z) 0.25))
           (grad-11 (* (.xxyy (vec2 (.y vec) (.y vec-1))) (sign hash-high-z)))
           (grad-12 (* (.z vec-1) (sign (- (abs hash-high-z) 0.125))))
           (grad-0 (+ grad-00 grad-01 grad-02))
           (grad-1 (+ grad-10 grad-11 grad-12))
           (blend (shape/quintic-curve vec))
           (out (mix grad-0 grad-1 (.z blend)))
           (blend (vec4 (.xy blend) (- 1 (.xy blend))))
           (out (* (dot out (* (.zxzx blend) (.wwyy blend))) (/ 2 3.0))))
    (map-domain out -1 1 0 1)))

(defun noise/perlin-improved ((point :vec3))
  (noise/perlin-improved point (lambda ((x :vec3)) (hash/fast32 x))))

(defun noise/perlin ((point :vec4)
                     (hash-fn
                      (function (:vec4)
                       (:vec4 :vec4 :vec4 :vec4
                        :vec4 :vec4 :vec4 :vec4
                        :vec4 :vec4 :vec4 :vec4
                        :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (vec-1 (1- vec))
           (a0 a1 a2 a3 b0 b1 b2 b3 c0 c1 c2 c3 d0 d1 d2 d3
               (funcall hash-fn cell))
           (a0 (- a0 0.5 +epsilon+))
           (a1 (- a1 0.5 +epsilon+))
           (a2 (- a2 0.5 +epsilon+))
           (a3 (- a3 0.5 +epsilon+))
           (b0 (- b0 0.5 +epsilon+))
           (b1 (- b1 0.5 +epsilon+))
           (b2 (- b2 0.5 +epsilon+))
           (b3 (- b3 0.5 +epsilon+))
           (c0 (- c0 0.5 +epsilon+))
           (c1 (- c1 0.5 +epsilon+))
           (c2 (- c2 0.5 +epsilon+))
           (c3 (- c3 0.5 +epsilon+))
           (d0 (- d0 0.5 +epsilon+))
           (d1 (- d1 0.5 +epsilon+))
           (d2 (- d2 0.5 +epsilon+))
           (d3 (- d3 0.5 +epsilon+))
           (temp-a (* (inversesqrt (+ (* a0 a0) (* a1 a1) (* a2 a2) (* a3 a3)))
                      (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) a0)
                         (* (.xxyy (vec2 (.y vec) (.y vec-1))) a1)
                         (* (.z vec) a2)
                         (* (.w vec) a3))))
           (temp-b (* (inversesqrt (+ (* b0 b0) (* b1 b1) (* b2 b2) (* b3 b3)))
                      (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) b0)
                         (* (.xxyy (vec2 (.y vec) (.y vec-1))) b1)
                         (* (.z vec-1) b2)
                         (* (.w vec) b3))))
           (temp-c (* (inversesqrt (+ (* c0 c0) (* c1 c1) (* c2 c2) (* c3 c3)))
                      (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) c0)
                         (* (.xxyy (vec2 (.y vec) (.y vec-1))) c1)
                         (* (.z vec) c2)
                         (* (.w vec-1) c3))))
           (temp-d (* (inversesqrt (+ (* d0 d0) (* d1 d1) (* d2 d2) (* d3 d3)))
                      (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) d0)
                         (* (.xxyy (vec2 (.y vec) (.y vec-1))) d1)
                         (* (.z vec-1) d2)
                         (* (.w vec-1) d3))))
           (blend (shape/quintic-curve vec))
           (temp (+ temp-a (* (- temp-c temp-a) (.w blend))))
           (temp (+ temp (* (- (+ temp-b (* (- temp-d temp-b) (.w blend))) temp)
                            (.z blend))))
           (blend (vec4 (.xy blend) (- 1 (.xy blend)))))
    (map-domain (dot temp (* (.zxzx blend) (.wwyy blend))) -1 1 0 1)))

(defun noise/perlin ((point :vec4))
  (noise/perlin point (lambda ((x :vec4)) (hash/fast32-2-4-per-corner x))))

(defun noise/polkadot ((point :vec2)
                       (radius-low :float)
                       (radius-high :float)
                       (hash-fn (function (:vec2) :vec4)))
  (let* ((cell (floor point))
         (vec (- point cell))
         (hash (funcall hash-fn cell))
         (radius (max 0 (+ radius-low
                           (* (.z hash) (- radius-high radius-low)))))
         (value (/ radius (max radius-high radius-low)))
         (radius (/ 2 radius))
         (vec (+ (* (.xy hash) (- radius 2))
                 (- (* vec radius) (1- radius)))))
    (* (shape/falloff-squared-c2 (min (dot vec vec) 1.0)) value)))

(defun noise/polkadot ((point :vec2)
                       (radius-low :float)
                       (radius-high :float))
  (noise/polkadot point radius-low radius-high (lambda ((x :vec2)) (hash/fast32-cell x))))

(defun noise/polkadot-box ((point :vec2)
                           (radius-low :float)
                           (radius-high :float)
                           (hash-fn (function (:vec2) :vec4)))
  (let* ((cell (floor point))
         (vec (- point cell))
         (hash (funcall hash-fn cell))
         (radius (max 0 (+ radius-low
                           (* (.z hash) (- radius-high radius-low)))))
         (value (/ radius (max radius-high radius-low)))
         (radius (/ 2 radius))
         (vec (expt (+ (* (.xy hash) (- radius 2))
                       (- (* vec radius) (1- radius)))
                    (vec2 2))))
    (* (shape/falloff-squared-c2 (min (dot vec vec) 1.0)) value)))

(defun noise/polkadot-box ((point :vec2)
                           (radius-low :float)
                           (radius-high :float))
  (noise/polkadot-box point radius-low radius-high (lambda ((x :vec2)) (hash/fast32-cell x))))

(defun noise/polkadot ((point :vec3)
                       (radius-low :float)
                       (radius-high :float)
                       (hash-fn (function (:vec3) :vec4)))
  (let* ((cell (floor point))
         (vec (- point cell))
         (hash (funcall hash-fn cell))
         (radius (max 0 (+ radius-low
                           (* (.w hash) (- radius-high radius-low)))))
         (value (/ radius (max radius-high radius-low)))
         (radius (/ 2 radius))
         (vec (+ (- (* vec radius) (1- radius))
                 (* (.xyz hash) (- radius 2)))))
    (* (shape/falloff-squared-c2 (min (dot vec vec) 1)) value)))

(defun noise/polkadot ((point :vec3)
                       (radius-low :float)
                       (radius-high :float))
  (noise/polkadot point radius-low radius-high (lambda ((x :vec3)) (hash/fast32-cell x))))

(defun noise/polkadot-box ((point :vec3)
                           (radius-low :float)
                           (radius-high :float)
                           (hash-fn (function (:vec3) :vec4)))
  (let* ((cell (floor point))
         (vec (- point cell))
         (hash (funcall hash-fn cell))
         (radius (max 0 (+ radius-low
                           (* (.w hash) (- radius-high radius-low)))))
         (value (/ radius (max radius-high radius-low)))
         (radius (/ 2 radius))
         (vec (+ (- (* vec radius) (1- radius))
                 (* (.xyz hash) (- radius 2))))
         (vec (* vec vec)))
    (* (shape/falloff-squared-c2 (min (dot vec vec) 1)) value)))

(defun noise/polkadot-box ((point :vec3)
                           (radius-low :float)
                           (radius-high :float))
  (noise/polkadot-box point radius-low radius-high (lambda ((x :vec3)) (hash/fast32-cell x))))

(defconstant +simplex-2d/skew-factor+ (* 0.5 (1- (sqrt 3))))

(defconstant +simplex-2d/unskew-factor+ (/ (- 3 (sqrt 3)) 6))

(defconstant +simplex-2d/triangle-height+ (sqrt 0.5))

(defconstant +simplex-2d/inverse-triangle-height+ (sqrt (/ 0.5)))

(defconstant +simplex-2d/inverse-triangle-half-edge-length+
  (/ (sqrt 0.75) (sqrt 0.125)))

(defconstant +simplex-2d/norm-factor+
  (/ (* 0.4082483 (expt (- 0.5 (expt 0.4082483 2)) 4) 2)))

(defconstant +simplex-3d/skew-factor+ (/ 3.0))

(defconstant +simplex-3d/unskew-factor+ (/ 6.0))

(defconstant +simplex-3d/pyramid-height+ (sqrt 0.5))

(defconstant +simplex-3d/inverse-pyramid-height+ (sqrt (/ 0.5)))

(defconstant +simplex-3d/inverse-triangle-half-edge-length+ (/ 2 (sqrt 0.75)))

(defconstant +simplex-3d/norm-factor+
  (/ (* 0.4330127 (expt (- 0.5 (expt 0.4330127 2)) 3) 2)))

(defun noise/simplex-get-corner-vectors ((point :vec3))
  (let* ((point (* point +simplex-3d/pyramid-height+))
         (cell1 (floor (+ point (dot point (vec3 +simplex-3d/skew-factor+)))))
         (x0 (+ (- point cell1) (dot cell1 (vec3 +simplex-3d/unskew-factor+))))
         (g (step (.yzx x0) (.xyz x0)))
         (l (- 1 g))
         (cell2 (min (.xyz g) (.zxy l)))
         (cell3 (max (.xyz g) (.zxy l)))
         (x1 (+ (- x0 cell2) +simplex-3d/unskew-factor+))
         (x2 (+ (- x0 cell3) +simplex-3d/skew-factor+))
         (x3 (- x0 0.5))
         (v1234-x (vec4 (.x x0) (.x x1) (.x x2) (.x x3)))
         (v1234-y (vec4 (.y x0) (.y x1) (.y x2) (.y x3)))
         (v1234-z (vec4 (.z x0) (.z x1) (.z x2) (.z x3))))
    (values cell1 cell2 cell3 v1234-x v1234-y v1234-z)))

(defun noise/simplex-get-surflet-weights ((v1234-x :vec4)
                                          (v1234-y :vec4)
                                          (v1234-z :vec4))
  (let* ((surflet-weights (+ (* v1234-x v1234-x)
                             (* v1234-y v1234-y)
                             (* v1234-z v1234-z)))
         (surflet-weights (max (- 0.5 surflet-weights) 0)))
    (* surflet-weights surflet-weights surflet-weights)))

(defun noise/simplex ((point :vec2)
                      (hash-fn (function (:vec2) (:vec4 :vec4))))
  (mvlet* ((simplex-points (vec3 (- 1 +simplex-2d/unskew-factor+)
                                 (- +simplex-2d/unskew-factor+)
                                 (- 1 (* 2 +simplex-2d/unskew-factor+))))
           (point (* point +simplex-2d/triangle-height+))
           (cell (floor (+ point (dot point (vec2 +simplex-2d/skew-factor+)))))
           (hash-x hash-y (funcall hash-fn cell))
           (v0 (- cell (dot cell (vec2 +simplex-2d/unskew-factor+)) point))
           (v1pos-v1hash (if (< (.x v0) (.y v0))
                             (vec4 (.xy simplex-points)
                                   (.y hash-x)
                                   (.y hash-y))
                             (vec4 (.yx simplex-points)
                                   (.z hash-x)
                                   (.z hash-y))))
           (v12 (+ (vec4 (.xy v1pos-v1hash) (.zz simplex-points)) (.xyxy v0)))
           (grad-x (- (vec3 (.x hash-x) (.z v1pos-v1hash) (.w hash-x)) 0.5
                      +epsilon+))
           (grad-y (- (vec3 (.x hash-y) (.w v1pos-v1hash) (.w hash-y)) 0.5
                      +epsilon+))
           (m (expt (max (- 0.5 (+ (* (vec3 (.x v0) (.xz v12))
                                      (vec3 (.x v0) (.xz v12)))
                                   (* (vec3 (.y v0) (.yw v12))
                                      (vec3 (.y v0) (.yw v12)))))
                         0)
                    (vec3 4)))
           (out (* (dot m (* (inversesqrt (+ (* grad-x grad-x)
                                             (* grad-y grad-y)))
                             (+ (* grad-x (vec3 (.x v0) (.xz v12)))
                                (* grad-y (vec3 (.y v0) (.yw v12))))))
                   +simplex-2d/norm-factor+)))
    (map-domain out -1 1 0 1)))

(defun noise/simplex ((point :vec2))
  (noise/simplex point (lambda ((x :vec2)) (hash/fast32-2-per-corner x))))

(defun noise/simplex/derivs ((point :vec2)
                             (hash-fn
                              (function (:vec2)
                               (:vec4 :vec4))))
  (mvlet* ((simplex-points (vec3 (- 1 +simplex-2d/unskew-factor+)
                                 (- +simplex-2d/unskew-factor+)
                                 (- 1 (* 2 +simplex-2d/unskew-factor+))))
           (point (* point +simplex-2d/triangle-height+))
           (cell (floor (+ point (dot point (vec2 +simplex-2d/skew-factor+)))))
           (hash-x hash-y (funcall hash-fn cell))
           (v0 (- cell (dot cell (vec2 +simplex-2d/unskew-factor+)) point))
           (v1pos-v1hash (if (< (.x v0) (.y v0))
                             (vec4 (.xy simplex-points)
                                   (.y hash-x)
                                   (.y hash-y))
                             (vec4 (.yx simplex-points)
                                   (.z hash-x)
                                   (.z hash-y))))
           (v12 (+ (vec4 (.xy v1pos-v1hash) (.zz simplex-points)) (.xyxy v0)))
           (grad-x (- (vec3 (.x hash-x) (.z v1pos-v1hash) (.w hash-x)) 0.5
                      +epsilon+))
           (grad-y (- (vec3 (.x hash-y) (.w v1pos-v1hash) (.w hash-y)) 0.5
                      +epsilon+))
           (norm (inversesqrt (+ (* grad-x grad-x) (* grad-y grad-y))))
           (grad-x (* grad-x norm))
           (grad-y (* grad-y norm))
           (grad-results (+ (* grad-x (vec3 (.x v0) (.xz v12)))
                            (* grad-y (vec3 (.y v0) (.yw v12)))))
           (m (max (- 0.5 (+ (* (vec3 (.x v0) (.xz v12))
                                (vec3 (.x v0) (.xz v12)))
                             (* (vec3 (.y v0) (.yw v12))
                                (vec3 (.y v0) (.yw v12)))))
                   0))
           (m2 (* m m))
           (m4 (* m2 m2))
           (temp (* 8 m2 m grad-results))
           (noise (map-domain
                   (dot m4 grad-results) -0.010080204 0.010080204 0 1))
           (derivs (* (vec2 (- (dot temp (vec3 (.x v0) (.xz v12)))
                               (dot m4 grad-x))
                            (- (dot temp (vec3 (.y v0) (.yw v12)))
                               (dot m4 grad-x)))
                      49.60217)))
    (vec3 noise derivs)))

(defun noise/simplex-derivs ((point :vec2))
  (noise/simplex-derivs point (lambda ((x :vec2)) (hash/fast32-2-per-corner x))))

(defun noise/simplex ((point :vec3)
                      (hash-fn
                       (function (:vec3 :vec3 :vec3)
                        (:vec4 :vec4 :vec4))))
  (mvlet* ((cell1 cell2 cell3 corners-x corners-y corners-z
                  (noise/simplex-get-corner-vectors point))
           (hash0 hash1 hash2 (funcall hash-fn cell1 cell2 cell3))
           (hash0 (- hash0 0.5 +epsilon+))
           (hash1 (- hash1 0.5 +epsilon+))
           (hash2 (- hash2 0.5 +epsilon+))
           (weights (noise/simplex-get-surflet-weights corners-x corners-y corners-z))
           (out (* (dot weights
                        (* (inversesqrt (+ (* hash0 hash0)
                                           (* hash1 hash1)
                                           (* hash2 hash2)))
                           (+ (* hash0 corners-x)
                              (* hash1 corners-y)
                              (* hash2 corners-z))))
                   +simplex-3d/norm-factor+)))
    (map-domain out -1 1 0 1)))

(defun noise/simplex ((point :vec3))
  (noise/simplex point (lambda ((x :vec3) (y :vec3) (z :vec3)) (hash/fast32-3-per-corner x y z))))

(defun noise/simplex-derivs ((point :vec3)
                             (hash-fn (function
                                       (:vec3 :vec3 :vec3)
                                       (:vec4 :vec4 :vec4))))
  (mvlet* ((cell1 cell2 cell3 corners-x corners-y corners-z
                  (noise/simplex-get-corner-vectors point))
           (hash0 hash1 hash2 (funcall hash-fn cell1 cell2 cell3))
           (hash0 (- hash0 0.5 +epsilon+))
           (hash1 (- hash1 0.5 +epsilon+))
           (hash2 (- hash2 0.5 +epsilon+))
           (norm (inversesqrt (+ (* hash0 hash0)
                                 (* hash1 hash1)
                                 (* hash2 hash2))))
           (hash0 (* hash0 norm))
           (hash1 (* hash1 norm))
           (hash2 (* hash2 norm))
           (grad-results (+ (* hash0 corners-x)
                            (* hash1 corners-y)
                            (* hash2 corners-z)))
           (m (+ (* corners-x corners-x)
                 (* corners-y corners-y)
                 (* corners-z corners-z)))
           (m (max (- 0.5 m) 0))
           (m2 (* m m))
           (m3 (* m m2))
           (temp (* -6 m2 grad-results))
           (noise (map-domain
                   (dot m3 grad-results) -0.026428998 0.026428998 0 1))
           (derivs (* (vec3 (+ (dot temp corners-x) (dot m3 hash0))
                            (+ (dot temp corners-y) (dot m3 hash1))
                            (+ (dot temp corners-z) (dot m3 hash2)))
                      18.918613)))
    (vec4 noise derivs)))

(defun noise/simplex-derivs ((point :vec3))
  (noise/simplex-derivs point
                        (lambda ((x :vec3) (y :vec3) (z :vec3))
                          (hash/fast32-3-per-corner x y z))))

(defun noise/simplex-cellular ((point :vec2)
                               (hash-fn (function (:vec2) (:vec4 :vec4))))
  (mvlet* ((jitter-window (* 0.105662435 +simplex-2d/inverse-triangle-height+))
           (simplex-points (* (vec3 (- 1 +simplex-2d/unskew-factor+)
                                    (- +simplex-2d/unskew-factor+)
                                    (- 1 (* 2 +simplex-2d/unskew-factor+)))
                              +simplex-2d/inverse-triangle-height+))
           (point (* point +simplex-2d/triangle-height+))
           (cell (floor (+ point (dot point (vec2 +simplex-2d/skew-factor+)))))
           (p0 (* (- cell (dot cell (vec2 +simplex-2d/unskew-factor+)) point)
                  +simplex-2d/inverse-triangle-height+))
           (hash-x hash-y (funcall hash-fn cell))
           (grad-x (+ (* (noise/cellular-weight-samples hash-x) jitter-window)
                      (.x p0)))
           (grad-x (vec4 (.x grad-x) (+ (.yzw grad-x) (.xyz simplex-points))))
           (grad-y (+ (* (noise/cellular-weight-samples hash-y) jitter-window)
                      (.y p0)))
           (grad-y (vec4 (.x grad-y) (+ (.yzw grad-y) (.yxz simplex-points))))
           (dist-sq (+ (* grad-x grad-x) (* grad-y grad-y)))
           (temp (min (.xy dist-sq) (.zw dist-sq))))
    (min (.x temp) (.y temp))))

(defun noise/simplex-cellular ((point :vec2))
  (noise/simplex-cellular point (lambda ((x :vec2)) (hash/fast32-2-per-corner x))))

(defun noise/simplex-cellular ((point :vec3)
                               (hash-fn
                                (function (:vec3 :vec3 :vec3)
                                 (:vec4 :vec4 :vec4))))
  (mvlet* ((cell1 cell2 cell3 corners-x corners-y corners-z
                  (noise/simplex-get-corner-vectors point))
           (hash-x hash-y hash-z (funcall hash-fn cell1 cell2 cell3))
           (jitter-window (* 0.059786577 +simplex-3d/inverse-pyramid-height+))
           (hash-x (* (noise/cellular-weight-samples hash-x) jitter-window))
           (hash-y (* (noise/cellular-weight-samples hash-y) jitter-window))
           (hash-z (* (noise/cellular-weight-samples hash-z) jitter-window))
           (corners-x (+ (* corners-x (vec4 +simplex-3d/inverse-pyramid-height+))
                         hash-x))
           (corners-y (+ (* corners-y (vec4 +simplex-3d/inverse-pyramid-height+))
                         hash-y))
           (corners-z (+ (* corners-z (vec4 +simplex-3d/inverse-pyramid-height+))
                         hash-z))
           (dist-sq (+ (* corners-x corners-x)
                       (* corners-y corners-y)
                       (* corners-z corners-z))))
    (min (min (.x dist-sq) (.y dist-sq))
         (min (.z dist-sq) (.w dist-sq)))))

(defun noise/simplex-cellular ((point :vec3))
  (noise/simplex-cellular point
                          (lambda ((x :vec3) (y :vec3) (z :vec3))
                            (hash/fast32-3-per-corner x y z))))

(defun noise/simplex-polkadot ((point :vec2)
                               (radius :float)
                               (max-dimness :float)
                               (hash-fn (function (:vec2) :vec4)))
  (let* ((simplex-points (vec3 (- 1 +simplex-2d/unskew-factor+)
                               (- +simplex-2d/unskew-factor+)
                               (- 1 (* +simplex-2d/unskew-factor+ 2))))
         (point (* point +simplex-2d/triangle-height+))
         (cell (floor (+ point (dot point (vec2 +simplex-2d/skew-factor+)))))
         (v0 (- cell (dot cell (vec2 +simplex-2d/unskew-factor+)) point))
         (hash (funcall hash-fn cell))
         (radius (/ +simplex-2d/inverse-triangle-half-edge-length+ radius))
         (corners-x (* (+ (vec4 0 (.xyz simplex-points)) (.x v0)) radius))
         (corners-y (* (+ (vec4 0 (.yxz simplex-points)) (.y v0)) radius))
         (point-distance (max (vec4 0) (- 1 (+ (* corners-x corners-x)
                                               (* corners-y corners-y))))))
    (dot (- 1 (* hash max-dimness)) (expt point-distance (vec4 3)))))

(defun noise/simplex-polkadot ((point :vec2)
                               (radius :float)
                               (max-dimness :float))
  (noise/simplex-polkadot point radius max-dimness (lambda ((x :vec2)) (hash/fast32 x))))

(defun noise/simplex-polkadot ((point :vec3)
                               (radius :float)
                               (max-dimness :float)
                               (hash-fn
                                (function (:vec3 :vec3 :vec3)
                                 :vec4)))
  (mvlet* ((cell1 cell2 cell3 corners-x corners-y corners-z
                  (noise/simplex-get-corner-vectors point))
           (hash (funcall hash-fn cell1 cell2 cell3))
           (radius (/ +simplex-3d/inverse-triangle-half-edge-length+ radius))
           (vx (* corners-x radius))
           (vy (* corners-y radius))
           (vz (* corners-z radius))
           (point-distance (max (vec4 0) (- 1 (+ (* vx vx)
                                                 (* vy vy)
                                                 (* vz vz))))))
    (setf point-distance (* point-distance point-distance point-distance))
    (dot (- 1 (* hash max-dimness)) point-distance)))

(defun noise/simplex-polkadot ((point :vec3)
                               (radius :float)
                               (max-dimness :float))
  (noise/simplex-polkadot point
                          radius
                          max-dimness
                          (lambda ((x :vec3) (y :vec3) (z :vec3))
                            (hash/fast32 x y z))))

(defun noise/value ((point :vec2)
                    (hash-fn (function (:vec2) :vec4)))
  (let* ((cell (floor point))
         (vec (- point cell))
         (hash (funcall hash-fn cell))
         (blend (shape/quintic-curve vec))
         (blend (vec4 blend (- 1 blend))))
    (dot hash (* (.zxzx blend) (.wwyy blend)))))

(defun noise/value ((point :vec2))
  (noise/value point (lambda ((x :vec2)) (hash/fast32 x))))

(defun noise/value-derivs ((point :vec2)
                           (hash-fn (function (:vec2) :vec4)))
  (let* ((cell (floor point))
         (vec (- point cell))
         (hash (funcall hash-fn cell))
         (blend (shape/quintic-curve-interpolate-derivative vec))
         (out (mix (.xyxz hash) (.zwyw hash) (.yyxx blend))))
    (+ (vec3 (.x out) 0 0)
       (* (- (.yyw out) (.xxz out)) (.xzw blend)))))

(defun noise/value-derivs ((point :vec2))
  (noise/value-derivs point (lambda ((x :vec2)) (hash/fast32 x))))

(defun noise/value ((point :vec3)
                    (hash-fn (function (:vec3) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (low-z high-z (funcall hash-fn cell))
           (blend (shape/quintic-curve vec))
           (out (mix low-z high-z (.z blend)))
           (blend (vec4 (.xy blend) (- 1 (.xy blend)))))
    (dot out (* (.zxzx blend) (.wwyy blend)))))

(defun noise/value ((point :vec3))
  (noise/value point (lambda ((x :vec3)) (hash/fast32 x))))

(defun noise/value-derivs ((point :vec3)
                           (hash-fn (function (:vec3) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (low-z high-z (funcall hash-fn cell))
           (blend (shape/quintic-curve vec))
           (temp1 (mix low-z high-z (.z blend)))
           (temp1 (mix (.xyxz temp1) (.zwyw temp1) (.yyxx blend)))
           (temp2 (mix (vec4 (.xy low-z) (.xy high-z))
                       (vec4 (.zw low-z) (.zw high-z))
                       (.y blend)))
           (temp2 (mix (.xz temp2) (.yw temp2) (.x blend))))
    (+ (vec4 (.x temp1) 0 0 0)
       (* (- (vec4 (.yyw temp1) (.y temp2)) (vec4 (.xxz temp1) (.x temp2)))
          (vec4 (.x blend) (shape/quintic-curve-derivative vec))))))

(defun noise/value-derivs ((point :vec3))
  (noise/value-derivs point (lambda ((x :vec3)) (hash/fast32 x))))

(defun noise/value ((point :vec4)
                    (hash-fn (function (:vec4) (:vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (z0w0 z1w0 z0w1 z1w1 (funcall hash-fn cell))
           (blend (shape/quintic-curve vec))
           (temp (+ z0w0 (* (- z0w1 z0w0) (.w blend))))
           (temp (+ temp (* (- (+ z1w0 (* (- z1w1 z1w0) (.w blend))) temp)
                            (.z blend))))
           (blend (vec4 (.xy blend) (- 1 (.xy blend)))))
    (dot temp (* (.zxzx blend) (.wwyy blend)))))

(defun noise/value ((point :vec4))
  (noise/value point (lambda ((x :vec4)) (hash/fast32-2 x))))

(defun noise/value-hermite ((point :vec2)
                            (value-scale :float)
                            (gradient-scale :float)
                            (normalization-value :float)
                            (hash-fn
                             (function (:vec2)
                              (:vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (hash-x hash-y hash-z (funcall hash-fn cell))
           (hash-x (* (- hash-z 0.5) value-scale))
           (hash-y (* (- hash-x 0.5 +epsilon+) gradient-scale))
           (hash-z (* (- hash-y 0.5 +epsilon+) gradient-scale))
           (out (shape/quintic-hermite
                 (.y vec)
                 (vec4 (.xy hash-x) (.xy hash-y))
                 (vec4 (.zw hash-x) (.zw hash-y))
                 (vec4 (.xy hash-z) 0 0)
                 (vec4 (.zw hash-z) 0 0)))
           (out (* (shape/quintic-hermite
                    (.x vec) (.x out) (.y out) (.z out) (.w out))
                   normalization-value)))
    (map-domain out -1 1 0 1)))

(defun noise/value-hermite ((point :vec2)
                            (value-scale :float)
                            (gradient-scale :float)
                            (normalization-value :float))
  (noise/value-hermite point
                       value-scale
                       gradient-scale
                       normalization-value
                       (lambda ((x :vec2)) (hash/fast32/3-per-corner x))))

(defun noise/value-hermite ((point :vec3)
                            (value-scale :float)
                            (gradient-scale :float)
                            (normalization-value :float)
                            (hash-fn
                             (function (:vec3)
                              (:vec4 :vec4 :vec4 :vec4
                               :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (hash-x0 hash-y0 hash-z0 hash-w0 hash-x1 hash-y1 hash-z1 hash-w1
                    (funcall hash-fn cell))
           (hash-x0 (* (- hash-x0 0.5) value-scale))
           (hash-y0 (* (- hash-y0 0.5 +epsilon+) gradient-scale))
           (hash-z0 (* (- hash-z0 0.5 +epsilon+) gradient-scale))
           (hash-w0 (* (- hash-w0 0.5 +epsilon+) gradient-scale))
           (hash-x1 (* (- hash-x1 0.5) value-scale))
           (hash-y1 (* (- hash-y1 0.5 +epsilon+) gradient-scale))
           (hash-z1 (* (- hash-z1 0.5 +epsilon+) gradient-scale))
           (hash-w1 (* (- hash-w1 0.5 +epsilon+) gradient-scale))
           (ival igrad-x igrad-y (shape/quintic-hermite
                                  (.z vec) hash-x0 hash-x1 hash-y0 hash-y1
                                  hash-z0 hash-z1 hash-w0 hash-w1))
           (out (shape/quintic-hermite
                 (.y vec)
                 (vec4 (.xy ival) (.xy igrad-x))
                 (vec4 (.zw ival) (.zw igrad-x))
                 (vec4 (.xy igrad-y) 0 0)
                 (vec4 (.zw igrad-y) 0 0)))
           (out (* (shape/quintic-hermite
                    (.x vec) (.x out) (.y out) (.z out) (.w out))
                   normalization-value)))
    (map-domain out -1 1 0 1)))

(defun noise/value-hermite ((point :vec3)
                            (value-scale :float)
                            (gradient-scale :float)
                            (normalization-value :float))
  (noise/value-hermite point
                       value-scale
                       gradient-scale
                       normalization-value
                       (lambda ((x :vec3)) (hash/fast32-4-per-corner x))))

(defun noise/value-perlin ((point :vec2)
                           (blend-value :float)
                           (hash-fn (function (:vec2) (:vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vecs (- (.xyxy point) (vec4 cell (1+ cell))))
           (hash hash-x hash-y (funcall hash-fn cell))
           (grad-x (- hash-x 0.5 +epsilon+))
           (grad-y (- hash-y 0.5 +epsilon+))
           (grad-results (mix (1- (* hash 2))
                              (* (inversesqrt (+ (* grad-x grad-x)
                                                 (* grad-y grad-y)))
                                 (+ (* grad-x (.xzxz vecs))
                                    (* grad-y (.yyww vecs)))
                                 1.4142135)
                              blend-value))
           (blend (shape/quintic-curve (.xy vecs)))
           (blend (vec4 blend (- 1 blend)))
           (out (dot grad-results (* (.zxzx blend) (.wwyy blend)))))
    (map-domain out -1 1 0 1)))

(defun noise/value-perlin ((point :vec2)
                           (blend-value :float))
  (noise/value-perlin point
                      blend-value
                      (lambda ((x :vec2))
                        (hash/fast32-3-per-corner x))))

(defun noise/value-perlin ((point :vec3)
                           (blend-value :float)
                           (hash-fn
                            (function (:vec3)
                             (:vec4 :vec4 :vec4 :vec4
                              :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (vec-1 (1- vec))
           (hash0 hash-x0 hash-y0 hash-z0 hash1 hash-x1 hash-y1 hash-z1
                  (funcall hash-fn cell))
           (grad-x0 (- hash-x0 0.5 +epsilon+))
           (grad-y0 (- hash-y0 0.5 +epsilon+))
           (grad-z0 (- hash-z0 0.5 +epsilon+))
           (grad-x1 (- hash-x1 0.5 +epsilon+))
           (grad-y1 (- hash-y1 0.5 +epsilon+))
           (grad-z1 (- hash-z1 0.5 +epsilon+))
           (temp1 (mix (1- (* hash0 2))
                       (* (inversesqrt (+ (* grad-x0 grad-x0)
                                          (* grad-y0 grad-y0)
                                          (* grad-z0 grad-z0)))
                          (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x0)
                             (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y0)
                             (* (.z vec) grad-z0))
                          1.1547005)
                       blend-value))
           (temp2 (mix (1- (* hash1 2))
                       (* (inversesqrt (+ (* grad-x1 grad-x1)
                                          (* grad-y1 grad-y1)
                                          (* grad-z1 grad-z1)))
                          (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x1)
                             (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y1)
                             (* (.z vec-1) grad-z1))
                          1.1547005)
                       blend-value))
           (blend (shape/quintic-curve vec))
           (out (mix temp1 temp2 (.z blend)))
           (blend (vec4 (.xy blend) (- 1 (.xy blend))))
           (out (dot out (* (.zxzx blend) (.wwyy blend)))))
    (map-domain out -1 1 0 1)))

(defun noise/value-perlin ((point :vec3)
                           (blend-value :float))
  (noise/value-perlin point
                      blend-value
                      (lambda ((x :vec3)) (hash/fast32-4-per-corner x))))

(defun noise/cubist ((point :vec2)
                     (range-clamp :vec2)
                     (hash-fn (function (:vec2) (:vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vecs (- (.xyxy point) (vec4 cell (1+ cell))))
           (hash-x hash-y hash (funcall hash-fn cell))
           (grad-x (- hash-x 0.5 +epsilon+))
           (grad-y (- hash-y 0.5 +epsilon+))
           (temp (* (- hash 0.5)
                    (/ (* (inversesqrt (+ (* grad-x grad-x) (* grad-y grad-y)))
                          (+ (* grad-x (.xzxz vecs))
                             (* grad-y (.yyww vecs)))))))
           (blend (shape/quintic-curve (.xy vecs)))
           (blend (vec4 blend (- 1 blend)))
           (out (dot temp (* (.zxzx blend) (.wwyy blend)))))
    (saturate (* (- out (.x range-clamp)) (.y range-clamp)))))

(defun noise/cubist ((point :vec2)
                     (range-clamp :vec2))
  (noise/cubist point range-clamp (lambda ((x :vec2)) (hash/fast32-3-per-corner x))))

(defun noise/cubist ((point :vec3)
                     (range-clamp :vec2)
                     (hash-fn
                      (function
                       (:vec3)
                       (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (vec-1 (1- vec))
           (hash-x0 hash-y0 hash-z0 hash0 hash-x1 hash-y1 hash-z1 hash1
                    (funcall hash-fn cell))
           (grad-x0 (- hash-x0 0.5 +epsilon+))
           (grad-y0 (- hash-y0 0.5 +epsilon+))
           (grad-z0 (- hash-z0 0.5 +epsilon+))
           (grad-x1 (- hash-x1 0.5 +epsilon+))
           (grad-y1 (- hash-y1 0.5 +epsilon+))
           (grad-z1 (- hash-z1 0.5 +epsilon+))
           (temp1 (* (- hash0 0.5)
                     (/ (* (inversesqrt (+ (* grad-x0 grad-x0)
                                           (* grad-y0 grad-y0)
                                           (* grad-z0 grad-z0)))
                           (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x0)
                              (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y0)
                              (* (.z vec) grad-z0))))))
           (temp2 (* (- hash1 0.5)
                     (/ (* (inversesqrt (+ (* grad-x1 grad-x1)
                                           (* grad-y1 grad-y1)
                                           (* grad-z1 grad-z1)))
                           (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x1)
                              (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y1)
                              (* (.z vec-1) grad-z1))))))
           (blend (shape/quintic-curve vec))
           (out (mix temp1 temp2 (.z blend)))
           (blend (vec4 (.xy blend) (- 1 (.xy blend)))))
    (saturate (* (- (dot out (* (.zxzx blend) (.wwyy blend)))
                    (.x range-clamp))
                 (.y range-clamp)))))

(defun noise/cubist ((point :vec3)
                     (range-clamp :vec2))
  (noise/cubist point range-clamp (lambda ((x :vec3)) (hash/fast32-4-per-corner x))))

(defun noise/stars ((point :vec2)
                    (probability-threshold :float)
                    (max-dimness :float)
                    (radius :float)
                    (hash-fn (function (:vec2) :vec4)))
  (let* ((cell (floor point))
         (vec (- point cell))
         (hash (funcall hash-fn cell))
         (value (- 1 (* max-dimness (.z hash)))))
    (multf vec (vec2 radius))
    (decf vec (vec2 (1- radius)))
    (incf vec (* (.xy hash) (- radius 2)))
    (if (< (.w hash) probability-threshold)
        (* (shape/falloff-squared-c1 (min (dot vec vec) 1)) value)
        0.0)))

(defun noise/stars ((point :vec2)
                    (probability-threshold :float)
                    (max-dimness :float)
                    (radius :float))
  (noise/stars point
               probability-threshold
               max-dimness
               radius
               (lambda ((x :vec2)) (hash/fast32-cell x))))

(defun noise/fbm-perlin ((point :vec2)
                         (octaves :uint)
                         (frequency :float)
                         (gain :float)
                         (lacunarity :float))
  (let ((value 0.0)
        (amplitude 0.5))
    (dotimes (i octaves)
      (incf value (* amplitude (noise/perlin (* point frequency))))
      (setf point (* point lacunarity)
            amplitude (* amplitude gain)))
    value))

(defun noise/fbm-perlin ((point :vec3)
                         (octaves :uint)
                         (frequency :float)
                         (gain :float)
                         (lacunarity :float))
  (let ((value 0.0)
        (amplitude 0.5))
    (dotimes (i octaves)
      (incf value (* amplitude (noise/perlin (* point frequency))))
      (setf point (* point lacunarity)
            amplitude (* amplitude gain)))
    value))

(defun noise/fbm-simplex ((point :vec2)
                          (octaves :uint)
                          (frequency :float)
                          (gain :float)
                          (lacunarity :float))
  (let ((value 0.0)
        (amplitude 0.5))
    (dotimes (i octaves)
      (incf value (* amplitude (noise/simplex (* point frequency))))
      (setf point (* point lacunarity)
            amplitude (* amplitude gain)))
    value))

(defun noise/fbm-simplex ((point :vec3)
                          (octaves :uint)
                          (frequency :float)
                          (gain :float)
                          (lacunarity :float))
  (let ((value 0.0)
        (amplitude 0.5))
    (dotimes (i octaves)
      (incf value (* amplitude (noise/simplex (* point frequency))))
      (setf point (* point lacunarity)
            amplitude (* amplitude gain)))
    value))

(defun noise/fbm-cellular ((point :vec2)
                           (octaves :uint)
                           (frequency :float)
                           (gain :float)
                           (lacunarity :float))
  (let ((value 0.0)
        (amplitude 0.5))
    (dotimes (i octaves)
      (incf value (* amplitude (noise/cellular-fast (* point frequency))))
      (setf point (* point lacunarity)
            amplitude (* amplitude gain)))
    value))

(defun noise/fbm-cellular ((point :vec3)
                           (octaves :uint)
                           (frequency :float)
                           (gain :float)
                           (lacunarity :float))
  (let ((value 0.0)
        (amplitude 0.5))
    (dotimes (i octaves)
      (incf value (* amplitude (noise/cellular-fast (* point frequency))))
      (setf point (* point lacunarity)
            amplitude (* amplitude gain)))
    value))

(defun noise/ridges-perlin ((point :vec2)
                            (octaves :uint)
                            (frequency :float)
                            (gain :float)
                            (lacunarity :float)
                            (exponent :float)
                            (offset :float))
  (let ((value 0.0)
        (amplitude 0.5)
        (previous 1.0))
    (dotimes (i octaves)
      (let* ((n (noise/perlin (* point frequency)))
             (n (- offset (abs n)))
             (n (expt n exponent)))
        (incf value (* n amplitude previous))
        (setf previous n
              frequency (* frequency lacunarity)
              amplitude (* amplitude gain))))
    value))

(defun noise/ridges-perlin ((point :vec3)
                            (octaves :uint)
                            (frequency :float)
                            (gain :float)
                            (lacunarity :float)
                            (exponent :float)
                            (offset :float))
  (let ((value 0.0)
        (amplitude 0.5)
        (previous 1.0))
    (dotimes (i octaves)
      (let* ((n (noise/perlin (* point frequency)))
             (n (- offset (abs n)))
             (n (expt n exponent)))
        (incf value (* n amplitude previous))
        (setf previous n
              frequency (* frequency lacunarity)
              amplitude (* amplitude gain))))
    value))

(defun noise/ridges-simplex ((point :vec2)
                             (octaves :uint)
                             (frequency :float)
                             (gain :float)
                             (lacunarity :float)
                             (exponent :float)
                             (offset :float))
  (let ((value 0.0)
        (amplitude 0.5)
        (previous 1.0))
    (dotimes (i octaves)
      (let* ((n (noise/simplex (* point frequency)))
             (n (- offset (abs n)))
             (n (expt n exponent)))
        (incf value (* n amplitude previous))
        (setf previous n
              frequency (* frequency lacunarity)
              amplitude (* amplitude gain))))
    value))

(defun noise/ridges-simplex ((point :vec3)
                             (octaves :uint)
                             (frequency :float)
                             (gain :float)
                             (lacunarity :float)
                             (exponent :float)
                             (offset :float))
  (let ((value 0.0)
        (amplitude 0.5)
        (previous 1.0))
    (dotimes (i octaves)
      (let* ((n (noise/simplex (* point frequency)))
             (n (- offset (abs n)))
             (n (expt n exponent)))
        (incf value (* n amplitude previous))
        (setf previous n
              frequency (* frequency lacunarity)
              amplitude (* amplitude gain))))
    value))

(defun noise/ridges-cellular ((point :vec2)
                              (octaves :uint)
                              (frequency :float)
                              (gain :float)
                              (lacunarity :float)
                              (exponent :float)
                              (offset :float))
  (let ((value 0.0)
        (amplitude 0.5)
        (previous 1.0))
    (dotimes (i octaves)
      (let* ((n (noise/cellular-fast (* point frequency)))
             (n (- offset (abs n)))
             (n (expt n exponent)))
        (incf value (* n amplitude previous))
        (setf previous n
              frequency (* frequency lacunarity)
              amplitude (* amplitude gain))))
    value))

(defun noise/ridges-cellular ((point :vec3)
                              (octaves :uint)
                              (frequency :float)
                              (gain :float)
                              (lacunarity :float)
                              (exponent :float)
                              (offset :float))
  (let ((value 0.0)
        (amplitude 0.5)
        (previous 1.0))
    (dotimes (i octaves)
      (let* ((n (noise/cellular-fast (* point frequency)))
             (n (- offset (abs n)))
             (n (expt n exponent)))
        (incf value (* n amplitude previous))
        (setf previous n
              frequency (* frequency lacunarity)
              amplitude (* amplitude gain))))
    value))

(defun noise/billow-perlin ((point :vec2)
                            (octaves :uint)
                            (frequency :float)
                            (gain :float)
                            (lacunarity :float))
  (let ((value 0.0)
        (amplitude 0.5))
    (dotimes (i octaves)
      (incf value (* (1- (* (abs (noise/perlin (* point frequency))) 2))
                     amplitude))
      (setf point (* point lacunarity)
            amplitude (* amplitude gain)))
    value))

(defun noise/billow-perlin ((point :vec3)
                            (octaves :uint)
                            (frequency :float)
                            (gain :float)
                            (lacunarity :float))
  (let ((value 0.0)
        (amplitude 0.5))
    (dotimes (i octaves)
      (incf value (* (1- (* (abs (noise/perlin (* point frequency))) 2))
                     amplitude))
      (setf point (* point lacunarity)
            amplitude (* amplitude gain)))
    value))

(defun noise/billow/simplex ((point :vec2)
                             (octaves :uint)
                             (frequency :float)
                             (gain :float)
                             (lacunarity :float))
  (let ((value 0.0)
        (amplitude 0.5))
    (dotimes (i octaves)
      (incf value (* (1- (* (abs (noise/simplex (* point frequency))) 2))
                     amplitude))
      (setf point (* point lacunarity)
            amplitude (* amplitude gain)))
    value))

(defun noise/billow-simplex ((point :vec3)
                             (octaves :uint)
                             (frequency :float)
                             (gain :float)
                             (lacunarity :float))
  (let ((value 0.0)
        (amplitude 0.5))
    (dotimes (i octaves)
      (incf value (* (1- (* (abs (noise/simplex (* point frequency))) 2))
                     amplitude))
      (setf point (* point lacunarity)
            amplitude (* amplitude gain)))
    value))

(defun noise/billow-cellular ((point :vec2)
                              (octaves :uint)
                              (frequency :float)
                              (gain :float)
                              (lacunarity :float))
  (let ((value 0.0)
        (amplitude 0.5))
    (dotimes (i octaves)
      (incf value (* (1- (* (abs (noise/cellular (* point frequency))) 2))
                     amplitude))
      (setf point (* point lacunarity)
            amplitude (* amplitude gain)))
    value))

(defun noise/billow-cellular ((point :vec3)
                              (octaves :uint)
                              (frequency :float)
                              (gain :float)
                              (lacunarity :float))
  (let ((value 0.0)
        (amplitude 0.5))
    (dotimes (i octaves)
      (incf value (* (1- (* (abs (cellular (* point frequency))) 2))
                     amplitude))
      (setf point (* point lacunarity)
            amplitude (* amplitude gain)))
    value))
