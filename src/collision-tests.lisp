(in-package #:zed)

(defgeneric collide-p (volume1 volume2)
  (:method ((volume1 collision-volume) (volume2 collision-volume))
    (error "No collision test defined for volume types ~s and ~s."
           (collision-volume-type volume1)
           (collision-volume-type volume2))))

(defmethod collide-p ((volume1 collision-volume-sphere)
                      (volume2 collision-volume-sphere))
  (declare (optimize speed))
  (<= (p3:distance-squared (collision-volume-world-center volume1)
                           (collision-volume-world-center volume2))
      (expt (+ (collision-volume-sphere-radius volume1)
               (collision-volume-sphere-radius volume2))
            2)))

(u:fn-> %collide-p/sphere-box (collision-volume-sphere collision-volume-box) boolean)
(declaim (inline %collide-p/sphere-box))
(defun %collide-p/sphere-box (sphere box)
  (declare (optimize speed))
  (let* ((sphere-center (collision-volume-world-center sphere))
         (point (v3:- (get-closest-point/box-point box sphere-center) sphere-center)))
    (declare (dynamic-extent point))
    (<= (v3:length-squared point)
        (expt (collision-volume-sphere-radius sphere) 2))))

(defmethod collide-p ((volume1 collision-volume-sphere) (volume2 collision-volume-box))
  (declare (optimize speed))
  (%collide-p/sphere-box volume1 volume2))

(defmethod collide-p ((volume1 collision-volume-box) (volume2 collision-volume-sphere))
  (declare (optimize speed))
  (%collide-p/sphere-box volume2 volume1))

(defmethod collide-p ((volume1 collision-volume-box) (volume2 collision-volume-box))
  (declare (optimize speed))
  (u:mvlet ((r r-abs (make-box-box-rotation volume1 volume2)))
    (m3:with-components ((r r) (ar r-abs))
      (v3:with-components ((tr (make-box-box-translation volume1 volume2))
                           (h1 (collision-volume-box-half-extents volume1))
                           (h2 (collision-volume-box-half-extents volume2)))
        (not (or (> (abs trx) (+ h1x (* h2x ar00) (* h2y ar01) (* h2z ar02)))
                 (> (abs try) (+ h1y (* h2x ar10) (* h2y ar11) (* h2z ar12)))
                 (> (abs trz) (+ h1z (* h2x ar20) (* h2y ar21) (* h2z ar22)))
                 (> (abs (+ (* trx r00) (* try r10) (* trz r20)))
                    (+ (* h1x ar00) (* h1y ar10) (* h1z ar20) h2x))
                 (> (abs (+ (* trx r01) (* try r11) (* trz r21)))
                    (+ (* h1x ar01) (* h1y ar11) (* h1z ar21) h2y))
                 (> (abs (+ (* trx r02) (* try r12) (* trz r22)))
                    (+ (* h1x ar02) (* h1y ar12) (* h1z ar22) h2z))
                 (> (abs (- (* trz r10) (* try r20)))
                    (+ (* h1y ar20) (* h1z ar10) (* h2y ar02) (* h2z ar01)))
                 (> (abs (- (* trz r11) (* try r21)))
                    (+ (* h1y ar21) (* h1z ar11) (* h2x ar02) (* h2z ar00)))
                 (> (abs (- (* trz r12) (* try r22)))
                    (+ (* h1y ar22) (* h1z ar12) (* h2x ar01) (* h2y ar00)))
                 (> (abs (- (* trx r20) (* trz r00)))
                    (+ (* h1x ar20) (* h1z ar00) (* h2y ar12) (* h2z ar11)))
                 (> (abs (- (* trx r21) (* trz r01)))
                    (+ (* h1x ar21) (* h1z ar01) (* h2x ar12) (* h2z ar10)))
                 (> (abs (- (* trx r22) (* trz r02)))
                    (+ (* h1x ar22) (* h1z ar02) (* h2x ar11) (* h2y ar10)))
                 (> (abs (- (* try r00) (* trx r10)))
                    (+ (* h1x ar10) (* h1y ar00) (* h2y ar22) (* h2z ar21)))
                 (> (abs (- (* try r01) (* trx r11)))
                    (+ (* h1x ar11) (* h1y ar01) (* h2x ar22) (* h2z ar20)))
                 (> (abs (- (* try r02) (* trx r12)))
                    (+ (* h1x ar12) (* h1y ar02) (* h2x ar21) (* h2y ar20)))))))))
