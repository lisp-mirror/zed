(in-package #:%zed.utility.bezier-curve)

(u:define-constant +matrix+ (m4:mat -1 3 -3 1 3 -6 3 0 -3 3 0 0 1 0 0 0) :test #'equalp)

(defstruct (curve
            (:constructor %make-curve)
            (:conc-name nil)
            (:predicate nil)
            (:copier nil))
  (divisions 100 :type fixnum)
  (geometry (make-array 0 :adjustable t :fill-pointer 0) :type vector)
  (arc-lengths (u:make-f32-array 0) :type u:f32a)
  (arc-lengths-update nil :type boolean))

(u:fn-> estimate-arc-lengths (curve) null)
(defun estimate-arc-lengths (curve)
  (declare (optimize speed))
  (setf (aref (arc-lengths curve) 0) 0.0)
  (loop :with max = (divisions curve)
        :for i :from 1 :to max
        :for previous :of-type v3:vec = (evaluate curve 0.0) :then current
        :for current :of-type v3:vec = (evaluate curve (/ i max))
        :sum (p3:distance previous current) :into length :of-type u:f32
        :do (setf (aref (arc-lengths curve) i) length)))

(defun verify-points (points)
  (unless (every (lambda (x) (typep x 'v3:vec)) points)
    (error "Points must be a list of 3-component vectors.")))

(u:fn-> ensure-point-list (sequence) list)
(declaim (inline ensure-point-list))
(defun ensure-point-list (points)
  (declare (optimize speed))
  (etypecase points
    (list points)
    (vector (map 'list #'identity points))))

(u:fn-> point-count-valid-p (fixnum) boolean)
(declaim (inline point-count-valid-p))
(defun point-count-valid-p (point-count)
  (declare (optimize speed))
  (and (> point-count 1)
       (= 1 (mod point-count 3))))

(defun point-index-present-p (curve index)
  (let ((geometry (geometry curve))
        (matrix-index (max 0 (floor (1- index) 3))))
    (<= 0 matrix-index (1- (length geometry)))))

(u:fn-> add-geometry (curve sequence) (values))
(defun add-geometry (curve points)
  (declare (optimize speed))
  (loop :with points = (ensure-point-list points)
        :with segment-count = (1+ (the fixnum (/ (- (list-length points) 4) 3)))
        :for (a b c d) :on points :by #'cdddr
        :for av :of-type v3:vec = a
        :for bv :of-type v3:vec = b
        :for cv :of-type v3:vec = c
        :for dv :of-type v3:vec = d
        :for index :of-type fixnum :from 0
        :when (< index segment-count)
          :do (let ((mat (m4:id)))
                (v3:with-components ((a av) (b bv) (c cv) (d dv))
                  (m4:set-column! mat mat (v4:vec ax ay az 0.0) 0)
                  (m4:set-column! mat mat (v4:vec bx by bz 0.0) 1)
                  (m4:set-column! mat mat (v4:vec cx cy cz 0.0) 2)
                  (m4:set-column! mat mat (v4:vec dx dy dz 0.0) 3)
                  (vector-push-extend mat (geometry curve)))))
  (setf (arc-lengths-update curve) t)
  (values))

(u:fn-> make-geometry (curve list) (values))
(defun make-geometry (curve points)
  (declare (optimize speed))
  (let ((point-count (list-length points)))
    (unless (point-count-valid-p point-count)
      (error "Invalid number of points: ~s." point-count))
    (verify-points points)
    (add-geometry curve points)
    (values)))

(defun add-points (curve points)
  (let* ((points (ensure-point-list points))
         (point-count (list-length points)))
    (unless (and (plusp point-count)
                 (zerop (mod point-count 3)))
      (error "Invalid number of points: ~s." point-count))
    (verify-points points)
    (let* ((geometry (geometry curve))
           (last-index (1- (length geometry)))
           (column (m4:get-column (aref geometry last-index) 3))
           (shared-point (v3:vec (v4:x column) (v4:y column) (v4:z column))))
      (add-geometry curve (cons shared-point points))
      nil)))

(defun edit-point (curve index value)
  (flet ((write-column (geometry value matrix-index column-index)
           (let ((matrix (aref geometry matrix-index)))
             (m4:set-column! matrix matrix value column-index))))
    (u:mvlet* ((geometry (geometry curve))
               (value (v4:vec (v3:x value) (v3:y value) (v3:z value) 0))
               (quot rem (floor (1- index) 3))
               (matrix-index (max 0 quot))
               (column-index (if (zerop index) 0 (1+ rem))))
      (unless (< matrix-index (length geometry))
        (error "There is no point to edit at index ~s." index))
      (write-column geometry value matrix-index column-index)
      (when (and (plusp index)
                 (zerop (mod index 3))
                 (< matrix-index (1- (length geometry))))
        (write-column geometry value (1+ matrix-index) 0))
      (values))))

(defun make-curve (points &key (divisions 100))
  (unless (evenp divisions)
    (error "Division count must be even."))
  (let* ((arc-lengths (u:make-f32-array (1+ divisions)))
         (curve (%make-curve :divisions divisions :arc-lengths arc-lengths)))
    (make-geometry curve points)
    curve))

(u:fn-> remap (curve u:f32) u:f32)
(defun remap (curve parameter)
  (declare (optimize speed))
  (flet ((%bisect (arc-lengths arc-length-count target)
           (loop :with high = (1- arc-length-count)
                 :with low = 0
                 :while (< low high)
                 :for index :of-type fixnum = 0 :then (+ low (floor (- high low) 2))
                 :do (if (< (aref arc-lengths index) target)
                         (setf low (1+ index))
                         (setf high index))
                 :finally (return index)))
         (%remap (arc-lengths arc-length-count target index)
           (let* ((before (aref arc-lengths index))
                  (after (aref arc-lengths (1+ index)))
                  (length (- after before))
                  (fraction (/ (- target before) length)))
             (max 0.0
                  (if (= before target)
                      (/ index (float (1- arc-length-count) 1.0))
                      (/ (+ index fraction) (1- arc-length-count)))))))
    (when (arc-lengths-update curve)
      (estimate-arc-lengths curve)
      (setf (arc-lengths-update curve) nil))
    (let* ((arc-lengths (arc-lengths curve))
           (arc-length-count (length arc-lengths))
           (target (* (aref arc-lengths (1- arc-length-count)) parameter))
           (index (%bisect arc-lengths arc-length-count target)))
      (%remap arc-lengths arc-length-count target index))))

(defun evaluate (curve parameter &key even-spacing-p)
  (unless (<= 0 parameter 1)
    (error "Parameter must be in the closed range [0..1]."))
  (u:mvlet* ((geometry (geometry curve))
             (geometry-length (length geometry))
             (parameter (if even-spacing-p (remap curve parameter) parameter))
             (index x (floor (* parameter geometry-length))))
    (when (and (= index geometry-length)
               (zerop x))
      (decf index)
      (setf x 1))
    (v4:with-components ((v (m4:*v4 (m4:* (aref geometry index) +matrix+)
                                    (v4:vec (* x x x) (* x x) x 1))))
      (v3:vec vx vy vz))))

(u:fn-> collect-points (curve fixnum &key (:even-spacing-p boolean)) list)
(defun collect-points (curve count &key even-spacing-p)
  (declare (optimize speed))
  (loop :for i :below count
        :collect (evaluate curve (/ i (float (1- count) 1.0)) :even-spacing-p even-spacing-p)))

(u:fn-> collect-segments (curve fixnum &key (:even-spacing-p boolean)) list)
(defun collect-segments (curve count &key even-spacing-p)
  (declare (optimize speed))
  (loop :for i :from 1 :to count
        :for p1 = (evaluate curve 0.0 :even-spacing-p even-spacing-p) :then p2
        :for p2 = (evaluate curve (/ i (float count 1.0)) :even-spacing-p even-spacing-p)
        :collect (list p1 p2)))
