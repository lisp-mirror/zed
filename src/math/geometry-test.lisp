(in-package #:zed.math.geometry.test)

(u:fn-> sphere/sphere (sphere:sphere sphere:sphere) boolean)
(defun sphere/sphere (sphere1 sphere2)
  (declare (optimize speed))
  (<= (p3:distance-squared (sphere:origin sphere1) (sphere:origin sphere2))
      (expt (+ (sphere:radius sphere1) (sphere:radius sphere2)) 2)))

(u:fn-> %sphere/obb (sphere:sphere obb:obb) boolean)
(declaim (inline %sphere/obb))
(defun %sphere/obb (sphere obb)
  (declare (optimize speed))
  (let* ((sphere-origin (sphere:origin sphere))
         (closest-point (geo.cp:obb obb sphere-origin)))
    (declare (dynamic-extent closest-point))
    (< (p3:distance-squared closest-point sphere-origin)
       (expt (sphere:radius sphere) 2))))

(u:fn-> sphere/obb (sphere:sphere obb:obb) boolean)
(defun sphere/obb (sphere obb)
  (declare (optimize speed))
  (%sphere/obb sphere obb))

(u:fn-> obb/sphere (obb:obb sphere:sphere) boolean)
(defun obb/sphere (obb sphere)
  (declare (optimize speed))
  (%sphere/obb sphere obb))

(u:fn-> obb/obb (obb:obb obb:obb) boolean)
(defun obb/obb (obb1 obb2)
  (declare (optimize speed))
  (let* ((rotation1 (obb:rotation obb1))
         (rotation2 (obb:rotation obb2))
         (obb1-x (m3:get-column rotation1 0))
         (obb1-y (m3:get-column rotation1 1))
         (obb1-z (m3:get-column rotation1 2))
         (obb2-x (m3:get-column rotation2 0))
         (obb2-y (m3:get-column rotation2 1))
         (obb2-z (m3:get-column rotation2 2))
         (axes (vector obb1-x
                       obb1-y
                       obb1-z
                       obb2-x
                       obb2-y
                       obb2-z
                       (v3:cross obb2-x obb1-x)
                       (v3:cross obb2-x obb1-y)
                       (v3:cross obb2-x obb1-z)
                       (v3:cross obb2-y obb1-x)
                       (v3:cross obb2-y obb1-y)
                       (v3:cross obb2-y obb1-z)
                       (v3:cross obb2-z obb1-x)
                       (v3:cross obb2-z obb1-y)
                       (v3:cross obb2-z obb1-z))))
    (declare (dynamic-extent obb1-x obb1-y obb1-z obb2-x obb2-y obb2-z axes))
    (dotimes (i 15)
      (let ((x (aref axes i)))
        (v2:with-components ((i1 (obb::interval obb1 x))
                             (i2 (obb::interval obb2 x)))
          (unless (and (<= i2x i1y) (<= i1x i2y))
            (return-from obb/obb nil)))))
    t))

(u:fn-> %frustum/aabb (frustum:frustum aabb:aabb) boolean)
(declaim (inline %frustum/aabb))
(defun %frustum/aabb (frustum aabb)
  (declare (optimize speed))
  (let ((min (aabb:min aabb))
        (max (aabb:max aabb))
        (planes (vector (frustum:left frustum)
                        (frustum:right frustum)
                        (frustum:top frustum)
                        (frustum:bottom frustum)
                        (frustum:near frustum)
                        (frustum:far frustum))))
    (declare (dynamic-extent min max planes))
    (v3:with-components ((min- min)
                         (max- max))
      (dotimes (i 6)
        (let ((plane (aref planes i))
              (axis-vertex (v3:zero)))
          (declare (v4:vec plane)
                   (dynamic-extent axis-vertex))
          (v4:with-components ((p plane))
            (v3:with-components ((v axis-vertex))
              (if (minusp px)
                  (setf vx min-x)
                  (setf vx max-x))
              (if (minusp py)
                  (setf vy min-y)
                  (setf vy max-y))
              (if (minusp pz)
                  (setf vz min-z)
                  (setf vz max-z))
              (let ((plane-normal (v3:vec px py pz)))
                (declare (dynamic-extent plane-normal))
                (when (minusp (+ (v3:dot plane-normal v) pw))
                  (return-from %frustum/aabb t)))))))
      nil)))

(u:fn-> frustum/aabb (frustum:frustum aabb:aabb) boolean)
(defun frustum/aabb (frustum aabb)
  (declare (optimize speed))
  (%frustum/aabb frustum aabb))

(u:fn-> aabb/frustum (aabb:aabb frustum:frustum) boolean)
(defun aabb/frustum (aabb frustum)
  (declare (optimize speed))
  (%frustum/aabb frustum aabb))
