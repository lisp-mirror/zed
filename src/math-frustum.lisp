(in-package #:zed.math.frustum)

(defstruct (frustum
            (:conc-name nil)
            (:predicate nil)
            (:copier nil))
  (left (v4:zero) :type v4:vec)
  (right (v4:zero) :type v4:vec)
  (top (v4:zero) :type v4:vec)
  (bottom (v4:zero) :type v4:vec)
  (near (v4:zero) :type v4:vec)
  (far (v4:zero) :type v4:vec))

(u:fn-> update (frustum m4:mat m4:mat) null)
(defun update (frustum view proj)
  (declare (optimize speed))
  (let ((vp (m4:* proj view)))
    (declare (dynamic-extent vp))
    (m4:with-components ((m vp))
      (v4:with-components ((l. (left frustum))
                           (r. (right frustum))
                           (t. (top frustum))
                           (b. (bottom frustum))
                           (n. (near frustum))
                           (f. (far frustum)))
        (setf l.x (+ m30 m00) l.y (+ m31 m01) l.z (+ m32 m02) l.w (+ m33 m03)
              r.x (- m30 m00) r.y (- m31 m01) r.z (- m32 m02) r.w (- m33 m03)
              t.x (- m30 m10) t.y (- m31 m11) t.z (- m32 m12) t.w (- m33 m13)
              b.x (+ m30 m10) b.y (+ m31 m11) b.z (+ m32 m12) b.w (+ m33 m13)
              n.x m20 n.y m21 n.z m22 n.w m23
              f.x (- m30 m20) f.y (- m31 m21) f.z (- m32 m22) f.w (- m33 m23))
        (let ((length (sqrt (the (u:f32 0.0) (+ (* l.x l.x) (* l.y l.y) (* l.z l.z))))))
          (setf l.x (/ l.x length)
                l.y (/ l.y length)
                l.z (/ l.z length)
                l.w (/ l.w length)))
        (let ((length (sqrt (the (u:f32 0.0) (+ (* r.x r.x) (* r.y r.y) (* r.z r.z))))))
          (setf r.x (/ r.x length)
                r.y (/ r.y length)
                r.z (/ r.z length)
                r.w (/ r.w length)))
        (let ((length (sqrt (the (u:f32 0.0) (+ (* t.x t.x) (* t.y t.y) (* t.z t.z))))))
          (setf t.x (/ t.x length)
                t.y (/ t.y length)
                t.z (/ t.z length)
                t.w (/ t.w length)))
        (let ((length (sqrt (the (u:f32 0.0) (+ (* b.x b.x) (* b.y b.y) (* b.z b.z))))))
          (setf b.x (/ b.x length)
                b.y (/ b.y length)
                b.z (/ b.z length)
                b.w (/ b.w length)))
        (let ((length (sqrt (the (u:f32 0.0) (+ (* n.x n.x) (* n.y n.y) (* n.z n.z))))))
          (setf n.x (/ n.x length)
                n.y (/ n.y length)
                n.z (/ n.z length)
                n.w (/ n.w length)))
        (let ((length (sqrt (the (u:f32 0.0) (+ (* f.x f.x) (* f.y f.y) (* f.z f.z))))))
          (setf f.x (/ f.x length)
                f.y (/ f.y length)
                f.z (/ f.z length)
                f.w (/ f.w length)))
        nil))))
