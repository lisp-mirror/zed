(in-package #:zed.math.obb)

(declaim (inline obb))
(defstruct (obb
            (:constructor obb)
            (:conc-name nil)
            (:predicate nil)
            (:copier nil))
  (origin (p3:point) :type p3:point)
  (size (v3:uniform 0.5) :type v3:vec)
  (rotation (m3:id) :type m3:mat)
  (temp/closest-point (p3:point) :type p3:point)
  (temp/translation (v3:zero) :type v3:vec))

(u:define-printer (obb stream :type nil)
  (format stream "OBB"))

(u:fn-> bounding-aabb! (aabb:aabb obb) aabb:aabb)
(defun bounding-aabb! (aabb obb)
  (declare (optimize speed))
  (v3:with-components ((v (size obb)))
    (let* ((origin (origin obb))
           (rotation (rotation obb))
           (p1 (v3:copy v))
           (p2 (v3:vec (- vx) vy vz))
           (p3 (v3:vec vx (- vy) vz))
           (p4 (v3:vec vx vy (- vz)))
           (p5 (v3:vec (- vx) (- vy) vz))
           (p6 (v3:vec vx (- vy) (- vz)))
           (p7 (v3:vec (- vx) vy (- vz)))
           (p8 (v3:vec (- vx) (- vy) (- vz))))
      (declare (dynamic-extent p1 p2 p3 p4 p5 p6 p7 p8))
      (m3:*v3! p1 rotation p1)
      (m3:*v3! p2 rotation p2)
      (m3:*v3! p3 rotation p3)
      (m3:*v3! p4 rotation p4)
      (m3:*v3! p5 rotation p5)
      (m3:*v3! p6 rotation p6)
      (m3:*v3! p7 rotation p7)
      (m3:*v3! p8 rotation p8)
      (v3:+! p1 origin p1)
      (v3:+! p2 origin p2)
      (v3:+! p3 origin p3)
      (v3:+! p4 origin p4)
      (v3:+! p5 origin p5)
      (v3:+! p6 origin p6)
      (v3:+! p7 origin p7)
      (v3:+! p8 origin p8)
      (v3:with-components ((p1 p1) (p2 p2) (p3 p3) (p4 p4) (p5 p5) (p6 p6) (p7 p7) (p8 p8))
        (let ((min (v3:vec (min p1x p2x p3x p4x p5x p6x p7x p8x)
                           (min p1y p2y p3y p4y p5y p6y p7y p8y)
                           (min p1z p2z p3z p4z p5z p6z p7z p8z)))
              (max (v3:vec (max p1x p2x p3x p4x p5x p6x p7x p8x)
                           (max p1y p2y p3y p4y p5y p6y p7y p8y)
                           (max p1z p2z p3z p4z p5z p6z p7z p8z))))
          (declare (dynamic-extent min max))
          (aabb:from-min/max! aabb min max)
          nil)))
    aabb))

(u:fn-> bounding-aabb (obb) aabb:aabb)
(defun bounding-aabb (obb)
  (declare (optimize speed))
  (bounding-aabb! (aabb:aabb) obb))

(u:fn-> closest-point (obb p3:point) p3:point)
(defun closest-point (obb point)
  (declare (optimize speed))
  (let* ((origin (origin obb))
         (rotation (rotation obb))
         (size (size obb))
         (d (v3:- point origin))
         (q (v3:copy! (temp/closest-point obb) origin)))
    (declare (dynamic-extent d))
    (dotimes (i 3)
      (let* ((e (aref size i))
             (axis (m3:get-column rotation i))
             (dist (u:clamp (v3:dot d axis) (- e) e)))
        (declare (dynamic-extent axis))
        (v3:scale! axis axis dist)
        (v3:+! q q axis)))
    q))

(u:fn-> make-obb-obb-rotation (obb obb) (values m3:mat m3:mat))
(defun make-obb-obb-rotation (obb1 obb2)
  (declare (optimize speed))
  (let* ((rotation1 (rotation obb1))
         (rotation2 (rotation obb2))
         (x1 (m3:get-column rotation1 0))
         (y1 (m3:get-column rotation1 1))
         (z1 (m3:get-column rotation1 2))
         (x2 (m3:get-column rotation2 0))
         (y2 (m3:get-column rotation2 1))
         (z2 (m3:get-column rotation2 2)))
    (declare (dynamic-extent x1 y1 z1 x2 y2 z2))
    (m3:with-components ((a (load-time-value (m3:id)))
                         (b (load-time-value (m3:id))))
      (setf a00 (v3:dot x1 x2)
            a10 (v3:dot y1 x2)
            a20 (v3:dot z1 x2)
            a01 (v3:dot x1 y2)
            a11 (v3:dot y1 y2)
            a21 (v3:dot z1 y2)
            a02 (v3:dot x1 z2)
            a12 (v3:dot y1 z1)
            a22 (v3:dot z1 z2)
            b00 (+ (abs a00) 1e-7)
            b10 (+ (abs a10) 1e-7)
            b20 (+ (abs a20) 1e-7)
            b01 (+ (abs a01) 1e-7)
            b11 (+ (abs a11) 1e-7)
            b21 (+ (abs a21) 1e-7)
            b02 (+ (abs a02) 1e-7)
            b12 (+ (abs a12) 1e-7)
            b22 (+ (abs a22) 1e-7))
      (values a b))))

(u:fn-> make-obb-obb-translation (obb obb) v3:vec)
(defun make-obb-obb-translation (obb1 obb2)
  (declare (optimize speed))
  (let* ((rotation (rotation obb1))
         (x (m3:get-column rotation 0))
         (y (m3:get-column rotation 1))
         (z (m3:get-column rotation 2))
         (translation (v3:- (origin obb2) (origin obb1))))
    (declare (dynamic-extent x y z translation))
    (v3:with-components ((v (temp/translation obb1)))
      (setf vx (v3:dot translation x)
            vy (v3:dot translation y)
            vz (v3:dot translation z))
      v)))
