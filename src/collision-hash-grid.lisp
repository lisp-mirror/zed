(in-package #:zed)

(defstruct (hash-grid
            (:constructor make-hash-grid
                (&key cell-size (bucket-size 4096)
                 &aux (buckets (make-array bucket-size :initial-element nil))))
            (:predicate nil)
            (:copier nil))
  (cell-size 32 :type u:positive-fixnum)
  (bucket-size 2048 :type u:ub32)
  (buckets nil :type (simple-array t (*))))

(u:define-constant +hash-grid-x+ #x8da6b343)
(u:define-constant +hash-grid-y+ #xd8163841)
(u:define-constant +hash-grid-z+ #xcb1ab31f)

(u:fn-> hash-grid-coordinates (hash-grid u:b32 u:b32 u:b32) u:array-index)
(defun hash-grid-coordinates (grid x y z)
  (declare (optimize speed))
  (mod (+ (logand (* +hash-grid-x+ x) #.(1- (expt 2 32)))
          (logand (* +hash-grid-y+ y) #.(1- (expt 2 32)))
          (logand (* +hash-grid-z+ z) #.(1- (expt 2 32))))
       (hash-grid-bucket-size grid)))

(u:fn-> hash-grid-insert (hash-grid collision-volume) null)
(defun hash-grid-insert (grid volume)
  (declare (optimize speed))
  (let* ((buckets (hash-grid-buckets grid))
         (cell-size (hash-grid-cell-size grid))
         (min (map '(vector fixnum)
                   (lambda (x)
                     (declare (fix-sf60 x))
                     (floor x cell-size))
                   (collision-volume-broad-phase-min volume)))
         (max (map '(vector fixnum)
                   (lambda (x)
                     (declare (fix-sf60 x))
                     (floor x cell-size))
                   (collision-volume-broad-phase-max volume))))
    (declare (dynamic-extent min max))
    (loop :for z :from (aref min 2) :to (aref max 2)
          :do (loop :for y :from (aref min 1) :to (aref max 1)
                    :do (loop :for x :from (aref min 0) :to (aref max 0)
                              :for hash = (hash-grid-coordinates grid x y z)
                              :do (push volume (aref buckets hash)))))))
