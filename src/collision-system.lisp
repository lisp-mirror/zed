(in-package #:zed)

(defstruct (collision-system
            (:constructor %make-collision-system)
            (:predicate nil)
            (:copier nil))
  (layers (u:dict #'eq) :type hash-table)
  (multi-level-p t :type boolean)
  (bucket-size 1024 :type u:positive-fixnum)
  (cell-sizes nil :type list)
  (grids (u:dict #'eql) :type hash-table)
  (volume-buffer (make-array 8 :fill-pointer 0 :adjustable t) :type (vector collision-volume))
  (visited-volumes (u:dict #'eq) :type hash-table)
  (contacts (u:dict #'eq) :type hash-table))

(u:define-printer (collision-system stream :type nil)
  (format stream "COLLISION-SYSTEM"))

(u:fn-> make-collision-system (symbol) collision-system)
(defun make-collision-system (plan-name)
  (declare (optimize speed))
  (let* ((plan (find-collision-plan plan-name))
         (multi-level-p (collision-plan-multi-level-p plan))
         (cell-size (collision-plan-cell-size plan))
         (system (%make-collision-system :multi-level-p multi-level-p
                                         :bucket-size (collision-plan-bucket-size plan)
                                         :layers (collision-plan-table plan))))
    (unless multi-level-p
      (register-collision-grid system cell-size))
    system))

(u:fn-> register-collision-grid (collision-system u:positive-fixnum) null)
(defun register-collision-grid (system cell-size)
  (declare (optimize speed))
  (let* ((grids (collision-system-grids system))
         (bucket-size (collision-system-bucket-size system))
         (cell-sizes (collision-system-cell-sizes system))
         (grid (make-hash-grid :bucket-size bucket-size :cell-size cell-size)))
    (unless (u:href grids cell-size)
      (setf (u:href grids cell-size) grid
            (collision-system-cell-sizes system) (sort (list* cell-size cell-sizes) #'<))))
  nil)

(u:fn-> ensure-collision-grid (context collision-volume) null)
(defun ensure-collision-grid (context volume)
  (let ((system (context-collision-system context)))
    (cond
      ((collision-system-multi-level-p system)
       (funcall (collision-volume-update-func volume) volume)
       (v3:with-components ((min- (collision-volume-broad-phase-min volume))
                            (max- (collision-volume-broad-phase-max volume)))
         (let* ((volume-size (max (- max-x min-x) (- max-y min-y) (- max-z min-z)))
                (cell-size (ash 1 (max 3 (integer-length (ceiling volume-size))))))
           (register-collision-grid system cell-size)
           (setf (collision-volume-grid-cell-size volume) cell-size))))
      (t
       (let ((cell-size (car (collision-system-cell-sizes system))))
         (setf (collision-volume-grid-cell-size volume) cell-size))))
    nil))

(u:fn-> register-collision-volume (collision-system collision-volume) null)
(defun register-collision-volume (system volume)
  (declare (optimize speed))
  (let ((cell-size (collision-volume-grid-cell-size volume)))
    (funcall (collision-volume-update-func volume) volume)
    (hash-grid-insert (u:href (collision-system-grids system) cell-size) volume))
  nil)

(u:fn-> volume-contact-p
        (collision-system collision-volume collision-volume)
        (or collision-volume null))
(defun volume-contact-p (system volume1 volume2)
  (declare (optimize speed))
  (let ((contacts (collision-system-contacts system)))
    (u:when-let ((contact (u:href contacts volume1)))
      (u:href contact volume2))))

(u:fn-> volume-contact-enter (collision-system collision-volume collision-volume) null)
(defun volume-contact-enter (system volume1 volume2)
  (declare (optimize speed))
  (flet ((%enter (volume1 volume2)
           (incf (collision-volume-contact-count volume1))
           (when (plusp (collision-volume-contact-count volume1))
             (setf (collision-volume-hit-p volume1) t))
           (when (plusp (collision-volume-contact-count volume2))
             (setf (collision-volume-hit-p volume2) t))
           #++(z::on-collision-enter)
           nil))
    (declare (inline %enter))
    (let ((contacts (collision-system-contacts system)))
      (u:if-let ((contact (u:href contacts volume1)))
        (setf (u:href contact volume2) volume2)
        (setf (u:href contacts volume1) (u:dict #'eq volume2 volume2)))
      (u:if-let ((contact (u:href contacts volume2)))
        (setf (u:href contact volume1) volume1)
        (setf (u:href contacts volume2) (u:dict #'eq volume1 volume1)))
      (%enter volume1 volume2)
      (%enter volume2 volume1)
      nil)))

(u:fn-> volume-contact-exit (collision-system collision-volume collision-volume) null)
(defun volume-contact-exit (system volume1 volume2)
  (declare (optimize speed))
  (flet ((%exit (volume1 volume2)
           (decf (collision-volume-contact-count volume1))
           (when (zerop (collision-volume-contact-count volume2))
             (setf (collision-volume-hit-p volume1) nil))
           (when (zerop (collision-volume-contact-count volume2))
             (setf (collision-volume-hit-p volume2) nil))
           #++(z::on-collision-exit)
           nil))
    (declare (inline %exit))
    (let ((contacts (collision-system-contacts system)))
      (u:when-let ((table2 (u:href contacts volume1)))
        (remhash volume2 table2)
        (when (zerop (hash-table-count table2))
          (remhash volume1 contacts)))
      (u:when-let ((table1 (u:href contacts volume2)))
        (remhash volume1 table1)
        (when (zerop (hash-table-count table1))
          (remhash volume2 contacts)))
      (%exit volume1 volume2)
      (%exit volume2 volume1)
      nil)))

(u:fn-> volume-contact-continue (collision-volume collision-volume) null)
(defun volume-contact-continue (volume1 volume2)
  (declare (optimize speed))
  (flet ((%continue (volume1 volume2)
           (declare (ignore volume1 volume2))))
    (declare (inline %continue))
    (%continue volume1 volume2)
    (%continue volume2 volume1)
    nil))

(u:fn-> compute-volume-contact (collision-system collision-volume collision-volume) null)
(defun compute-volume-contact (system volume1 volume2)
  (declare (optimize speed))
  (let* ((collided-p (collide-p volume1 volume2))
         (contact-p (volume-contact-p system volume1 volume2)))
    (cond
      ((and collided-p contact-p)
       (volume-contact-continue volume1 volume2))
      ((and collided-p (not contact-p))
       (volume-contact-enter system volume1 volume2))
      ((and (not collided-p) contact-p)
       (volume-contact-exit system volume1 volume2)))))

(u:fn-> merge-collision-grid-bucket (collision-system u:ub32 u:ub32) (vector collision-volume))
(declaim (inline merge-collision-grid-bucket))
(defun merge-collision-grid-bucket (system start-size hash)
  (declare (optimize speed))
  (let ((grids (collision-system-grids system))
        (visited (collision-system-visited-volumes system))
        (buffer (collision-system-volume-buffer system)))
    (clrhash visited)
    (setf (fill-pointer buffer) 0)
    (u:do-hash (cell-size grid grids)
      (when (>= (the u:ub32 cell-size) start-size)
        (map nil
             (lambda (x)
               (unless (u:href visited x)
                 (vector-push-extend x buffer)
                 (setf (u:href visited x) t)))
             (aref (hash-grid-buckets grid) hash))))
    buffer))

(u:fn-> %compute-collisions (collision-system hash-table vector) null)
(declaim (inline %compute-collisions))
(defun %compute-collisions (system layers bucket)
  (declare (optimize speed))
  (when (>= (length bucket) 2)
    (u:map-combinations
     (lambda (x)
       (let ((volume1 (svref x 0))
             (volume2 (svref x 1)))
         (when (u:href layers
                       (collision-volume-layer volume1)
                       (collision-volume-layer volume2))
           (compute-volume-contact system volume1 volume2))))
     bucket
     :copy nil
     :length 2))
  nil)

(u:fn-> compute-collisions/multi-level (collision-system) null)
(declaim (inline compute-collisions/multi-level))
(defun compute-collisions/multi-level (system)
  (declare (optimize speed))
  (let ((grids (collision-system-grids system))
        (layers (collision-system-layers system)))
    (dolist (cell-size (collision-system-cell-sizes system))
      (let* ((grid (u:href grids cell-size))
             (buckets (hash-grid-buckets grid)))
        (loop :for hash :of-type fixnum :from 0
              :for local-bucket :across buckets
              :when local-bucket
                :do (let ((bucket (merge-collision-grid-bucket system cell-size hash)))
                      (%compute-collisions system layers bucket)))
        (map nil (lambda (x) (setf (fill-pointer x) 0)) buckets)))))

(u:fn-> compute-collisions/flat (collision-system) null)
(declaim (inline compute-collisions/flat))
(defun compute-collisions/flat (system)
  (declare (optimize speed))
  (let* ((layers (collision-system-layers system))
         (grids (collision-system-grids system))
         (grid (u:href grids (car (collision-system-cell-sizes system))))
         (buckets (hash-grid-buckets grid)))
    (loop :for hash :of-type fixnum :from 0
          :for bucket :of-type vector :across buckets
          :when bucket
            :do (%compute-collisions system layers bucket))
    (map nil (lambda (x) (setf (fill-pointer x) 0)) buckets)))

(u:fn-> compute-collisions (context) null)
(defun compute-collisions (context)
  (declare (optimize speed))
  (let ((system (context-collision-system context)))
    (if (collision-system-multi-level-p system)
        (compute-collisions/multi-level system)
        (compute-collisions/flat system))))
