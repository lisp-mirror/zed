(defpackage #:%zed.utility.octree
  (:local-nicknames
   (#:p3 #:zed.math.point3d)
   (#:u #:golden-utils)
   (#:v3 #:zed.math.vector3))
  (:use #:cl)
  (:shadow
   #:count
   #:search))

(in-package #:%zed.utility.octree)

(deftype octant-id () 'u:ub32)
(deftype query-result () '(member :disjoint :overlaps :contains :inside))

(declaim (inline %make-octant))
(defstruct (octant
            (:constructor %make-octant)
            (:predicate nil)
            (:copier nil)
            (:conc-name nil))
  (parent nil :type (or octant-id null))
  (children (make-array 8 :fill-pointer 0 :adjustable t) :type (vector octant))
  (center (p3:point 0.0 0.0 0.0) :type p3:point)
  (extent 0.0 :type u:f32)
  (rank 0 :type u:ub32)
  (point-indices (make-array 32 :element-type 'u:ub32 :fill-pointer 0 :adjustable t)
   :type (vector u:ub32)))

(declaim (inline %make-octree))
(defstruct (octree
            (:constructor %make-octree)
            (:predicate nil)
            (:copier nil)
            (:conc-name nil))
  (octants (make-array 32 :fill-pointer 0 :adjustable t) :type (vector octant))
  (points (vector) :type simple-vector))

(u:define-printer (octant stream)
  (format stream "OCTANT (~d children, ~d points)"
          (length (children octant))
          (length (point-indices octant))))

(u:define-printer (octree stream)
  (format stream "OCTREE (~d octants, ~d points)"
          (length (octants octree))
          (length (points octree))))

(u:fn-> make-octant (u:f32) octant)
(defun make-octant (extent)
  (%make-octant :extent extent))

(u:fn-> make-root-octant (simple-vector) octant)
(defun make-root-octant (points)
  (declare (optimize speed))
  (u:mvlet ((point-count (length points))
            (min max (p3:find-min-max points)))
    (v3:with-components ((w (v3:- max min)))
      (let ((octant (make-octant (* (max wx wy wz) 0.5))))
        (dotimes (i point-count)
          (vector-push-extend i (point-indices octant)))
        (setf (center octant) (v3:scale (v3:+ max min) 0.5))
        octant))))

(u:fn-> octants-neighbor-p (octant octant) boolean)
(defun octants-neighbor-p (octant1 octant2)
  (declare (optimize speed))
  (let ((e (+ (extent octant1) (extent octant2)))
        (c1 (center octant1))
        (c2 (center octant2)))
    (dotimes (i 3)
      (when (plusp (- (abs (- (aref c2 i) (aref c1 i))) e))
        (return-from octants-neighbor-p nil)))
    t))

(u:fn-> get-octant-cell-index (p3:point) u:ub8)
(declaim (inline get-octant-cell-index))
(defun get-octant-cell-index (point)
  (declare (optimize speed))
  (+ (if (plusp (p3:x point)) 0 1)
     (if (plusp (p3:y point)) 0 2)
     (if (plusp (p3:z point)) 0 4)))

(u:fn-> get-octant-cell-factor (u:ub8) p3:point)
(declaim (inline get-octant-cell-factor))
(defun get-octant-cell-factor (index)
  (declare (optimize speed))
  (p3:point (if (zerop (logand index 1)) 1.0 -1.0)
            (if (zerop (ash (logand index 2) -1)) 1.0 -1.0)
            (if (zerop (ash (logand index 4) -2)) 1.0 -1.0)))

(u:fn-> find-octant (octree octant-id) octant)
(declaim (inline find-octant))
(defun find-octant (octree octant-id)
  (declare (optimize speed))
  (let ((octants (octants octree)))
    (locally (declare #+sbcl ((and (vector octant) (not simple-array)) octants))
      (aref octants octant-id))))

(u:fn-> make-octree (simple-vector) octree)
(defun make-octree (points)
  (declare (optimize speed))
  (let ((root (make-root-octant points))
        (octree (%make-octree :points points)))
    (vector-push-extend root (octants octree))
    octree))

(u:fn-> insert (octree octant) octant-id)
(declaim (inline insert))
(defun insert (octree octant)
  (declare (optimize speed))
  (let* ((octants (octants octree))
         (id (length octants)))
    (vector-push-extend octant octants)
    id))

(u:fn-> insert-child (octree octant-id octant) octant-id)
(defun insert-child (octree parent-id child)
  (declare (optimize speed))
  (let* ((id (insert octree child))
         (parent (find-octant octree parent-id))
         (parent-children (children parent)))
    (setf (parent child) parent-id
          (rank child) (length parent-children))
    (vector-push-extend id parent-children)
    id))

(u:fn-> create-children (octant simple-vector) simple-vector)
(defun create-children (octant points)
  (declare (optimize speed))
  (let ((extent (* (extent octant) 0.5))
        (center (center octant))
        (children (make-array 8))
        (point-indices (point-indices octant)))
    (dotimes (i 8)
      (let ((child (make-octant extent))
            (factors (get-octant-cell-factor i)))
        (v3:+! (center child) (v3:scale factors extent) center)
        (setf (aref children i) child)))
    (when (> (length point-indices) 1)
      (map nil
           (lambda (x)
             (let ((index (get-octant-cell-index (v3:- (aref points x) center))))
               (vector-push-extend x (point-indices (aref children index)))))
           point-indices))
    children))

(u:fn-> split-octant (octree octant-id) null)
(declaim (inline split-octant))
(defun split-octant (octree parent-id)
  (declare (optimize speed))
  (let* ((parent (find-octant octree parent-id))
         (children (create-children parent (points octree))))
    (map nil (lambda (x) (insert-child octree parent-id x)) children)))

(u:fn-> count (octree) u:ub32)
(declaim (inline count))
(defun count (octree)
  (declare (optimize speed))
  (length (octants octree)))

(u:fn-> build (octree (and (integer 1) u:ub32)) null)
(defun build (octree bucket-size)
  (declare (optimize speed))
  (when (> (length (points octree)) bucket-size)
    (let ((to-split (list 0)))
      (u:while to-split
        (let ((remaining nil))
          (dolist (parent-id to-split)
            (split-octant octree parent-id)
            (map nil
                 (lambda (x)
                   (let ((octant (find-octant octree x)))
                     (when (> (length (point-indices octant)) bucket-size)
                       (push x remaining))))
                 (children (find-octant octree parent-id))))
          (setf to-split (nreverse remaining)))))))

(u:fn-> query (octant v3:vec u:f32) query-result)
(defun query (octant origin radius)
  (declare (optimize speed))
  (let* ((e (extent octant))
         (c (v3:abs (v3:- origin (center octant))))
         (rsq (* radius radius))
         (max (+ e radius)))
    (when (or (> (v3:x c) max) (> (v3:y c) max) (> (v3:z c) max))
      (return-from query :disjoint))
    (when (or (< (v3:x c) e) (< (v3:y c) e) (< (v3:z c) e))
      (if (and (>= e radius) (v3:<= c (v3:uniform (- e radius))))
          (return-from query :inside)
          (when (and (v3:<= c (v3:uniform e))
                     (<= (p3:distance-squared c (v3:uniform (- e))) rsq))
            (return-from query :contains)))
      (return-from query :overlaps))
    (if (> (p3:distance-squared c (v3:uniform e)) rsq)
        :disjoint
        :overlaps)))

(u:fn-> search (octree p3:point u:f32) list)
(defun search (octree point radius)
  (declare (optimize speed))
  (let ((radius-squared (expt radius 2))
        (points (points octree))
        (result nil)
        (to-visit (list 0)))
    (flet ((collect-points (octant)
             (map nil
                  (lambda (x)
                    (let ((p (aref points x)))
                      (when (< (p3:distance-squared p point) radius-squared)
                        (push p result))))
                  (point-indices octant))))
      (u:while t
        (let ((todo nil))
          (dolist (parent-id to-visit)
            (let ((octant (find-octant octree parent-id)))
              (case (query octant point radius)
                ((:overlaps :inside)
                 (let ((children (children octant)))
                   (if (zerop (length children))
                       (map nil (lambda (x) (push x todo)) children)
                       (collect-points octant))))
                (:contains
                 (collect-points octant)))))
          (unless todo
            (loop-finish))
          (setf to-visit todo)))
      result)))
