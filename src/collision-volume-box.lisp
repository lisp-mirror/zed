(in-package #:zed)

(declaim (inline make-collision-volume-box))
(defstruct (collision-volume-box
            (:include collision-volume
             (type :box)
             (mesh-name "box")
             (update-func #'update-collision-volume-box))
            (:predicate nil)
            (:copier nil))
  (axes (m3:zero) :type m3:mat)
  (half-extents (v3:zero) :type v3:vec)
  (min (v3:uniform -0.5) :type v3:vec)
  (max (v3:uniform 0.5) :type v3:vec)
  (temp/closest-point (v3:zero) :type v3:vec)
  (temp/translation (v3:zero) :type v3:vec))

(u:fn-> get-closest-point/box-point (collision-volume-box v3:vec) v3:vec)
(defun get-closest-point/box-point (box point)
  (declare (optimize speed))
  (let* ((world-center (collision-volume-world-center box))
         (axes (collision-volume-box-axes box))
         (d (v3:- point world-center))
         (q (v3:copy! (collision-volume-box-temp/closest-point box) world-center)))
    (declare (dynamic-extent d))
    (dotimes (i 3)
      (let* ((e (aref (collision-volume-box-half-extents box) i))
             (axis (m3:get-column axes i))
             (dist (u:clamp (v3:dot d axis) (- e) e)))
        (declare (dynamic-extent axis))
        (v3:scale! axis axis dist)
        (v3:+! q q axis)))
    q))

(u:fn-> make-box-box-rotation (collision-volume-box collision-volume-box) (values m3:mat m3:mat))
(defun make-box-box-rotation (box1 box2)
  (declare (optimize speed))
  (let* ((axes1 (collision-volume-box-axes box1))
         (axes2 (collision-volume-box-axes box2))
         (x1 (m3:get-column axes1 0))
         (y1 (m3:get-column axes1 1))
         (z1 (m3:get-column axes1 2))
         (x2 (m3:get-column axes2 0))
         (y2 (m3:get-column axes2 1))
         (z2 (m3:get-column axes2 2)))
    (declare (dynamic-extent x1 y1 z1 x2 y2 z2))
    (m3:with-components ((a (load-time-value (m3:id)))
                         (b (load-time-value (m3:id))))
      (setf a00 (v3:dot x1 x2)
            a10 (v3:dot y1 x2)
            a20 (v3:dot z1 x2)
            a01 (v3:dot x1 y2)
            a11 (v3:dot y1 y2)
            a21 (v3:dot z1 y2)
            a02 (v3:dot x1 z2)
            a12 (v3:dot y1 z1)
            a22 (v3:dot z1 z2)
            b00 (+ (abs a00) 1e-7)
            b10 (+ (abs a10) 1e-7)
            b20 (+ (abs a20) 1e-7)
            b01 (+ (abs a01) 1e-7)
            b11 (+ (abs a11) 1e-7)
            b21 (+ (abs a21) 1e-7)
            b02 (+ (abs a02) 1e-7)
            b12 (+ (abs a12) 1e-7)
            b22 (+ (abs a22) 1e-7))
      (values a b))))

(u:fn-> make-box-box-translation (collision-volume-box collision-volume-box) v3:vec)
(defun make-box-box-translation (box1 box2)
  (declare (optimize speed))
  (let* ((axes (collision-volume-box-axes box1))
         (x (m3:get-column axes 0))
         (y (m3:get-column axes 1))
         (z (m3:get-column axes 2))
         (translation (v3:- (collision-volume-world-center box2)
                            (collision-volume-world-center box1))))
    (declare (dynamic-extent x y z translation))
    (v3:with-components ((v (collision-volume-box-temp/translation box1)))
      (setf vx (v3:dot translation x)
            vy (v3:dot translation y)
            vz (v3:dot translation z))
      v)))

(u:fn-> update-broad-phase-box (collision-volume-box) null)
(defun update-broad-phase-box (box)
  (declare (optimize speed))
  (v3:with-components ((v (collision-volume-box-half-extents box)))
    (let* ((center (collision-volume-world-center box))
           (axes (collision-volume-box-axes box))
           (p1 (v3:copy v))
           (p2 (v3:vec (- vx) vy vz))
           (p3 (v3:vec vx (- vy) vz))
           (p4 (v3:vec vx vy (- vz)))
           (p5 (v3:vec (- vx) (- vy) vz))
           (p6 (v3:vec vx (- vy) (- vz)))
           (p7 (v3:vec (- vx) vy (- vz)))
           (p8 (v3:vec (- vx) (- vy) (- vz))))
      (declare (dynamic-extent p1 p2 p3 p4 p5 p6 p7 p8))
      (m3:*v3! p1 axes p1)
      (m3:*v3! p2 axes p2)
      (m3:*v3! p3 axes p3)
      (m3:*v3! p4 axes p4)
      (m3:*v3! p5 axes p5)
      (m3:*v3! p6 axes p6)
      (m3:*v3! p7 axes p7)
      (m3:*v3! p8 axes p8)
      (v3:+! p1 center p1)
      (v3:+! p2 center p2)
      (v3:+! p3 center p3)
      (v3:+! p4 center p4)
      (v3:+! p5 center p5)
      (v3:+! p6 center p6)
      (v3:+! p7 center p7)
      (v3:+! p8 center p8)
      (v3:with-components ((p1 p1) (p2 p2) (p3 p3) (p4 p4) (p5 p5) (p6 p6) (p7 p7) (p8 p8)
                           (min- (collision-volume-broad-phase-min box))
                           (max- (collision-volume-broad-phase-max box)))
        (setf min-x (min p1x p2x p3x p4x p5x p6x p7x p8x)
              min-y (min p1y p2y p3y p4y p5y p6y p7y p8y)
              min-z (min p1z p2z p3z p4z p5z p6z p7z p8z)
              max-x (max p1x p2x p3x p4x p5x p6x p7x p8x)
              max-y (max p1y p2y p3y p4y p5y p6y p7y p8y)
              max-z (max p1z p2z p3z p4z p5z p6z p7z p8z))
        nil))))

(u:fn-> update-collision-volume-box (collision-volume-box) null)
(defun update-collision-volume-box (box)
  (declare (optimize speed))
  (let* ((collider (collision-volume-collider box))
         (owner (trait-owner collider))
         (center (collision-volume-center box))
         (min (v3:zero))
         (max (v3:zero))
         (transform (get-transform owner :space :world))
         (axes (collision-volume-box-axes box)))
    (declare (dynamic-extent min max))
    (transform-point! owner (v3:+ center (collision-volume-box-min box)) min)
    (transform-point! owner (v3:+ center (collision-volume-box-max box)) max)
    (m4:normalize-rotation! transform transform)
    (m4:rotation-to-mat3! axes transform)
    (let* ((world-center (v3:lerp! (collision-volume-world-center box) min max 0.5))
           (diagonal (v3:- max world-center))
           (x (m3:get-column axes 0))
           (y (m3:get-column axes 1))
           (z (m3:get-column axes 2)))
      (declare (dynamic-extent diagonal x y z))
      (v3:with-components ((h (collision-volume-box-half-extents box)))
        (setf (collision-volume-world-center box) world-center
              hx (v3:dot diagonal x)
              hy (v3:dot diagonal y)
              hz (v3:dot diagonal z))))
    (update-broad-phase-box box))
  nil)
