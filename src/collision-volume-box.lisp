(in-package #:zed)

(declaim (inline make-collision-volume-box))
(defstruct (collision-volume-box
            (:include collision-volume
             (type :box)
             (mesh-name "box")
             (update-func #'update-collision-volume-box))
            (:predicate nil)
            (:copier nil))
  (axes (m3:zero) :type m3:mat)
  (half-extents (v3:zero) :type v3:vec)
  (min (v3:uniform -0.5) :type v3:vec)
  (max (v3:uniform 0.5) :type v3:vec))

(u:fn-> get-closest-point/box-point (collision-volume-box v3:vec) v3:vec)
(defun get-closest-point/box-point (box point)
  (declare (optimize speed))
  (let* ((world-center (collision-volume-world-center box))
         (axes (collision-volume-box-axes box))
         (d (v3:- point world-center))
         (q (v3:copy world-center)))
    (declare (dynamic-extent d))
    (dotimes (i 3)
      (let* ((e (aref (collision-volume-box-half-extents box) i))
             (axis (m3:get-column axes i))
             (dist (u:clamp (v3:dot d axis) (- e) e)))
        (declare (dynamic-extent axis))
        (v3:scale! axis axis dist)
        (v3:+! q q axis)))
    q))

(u:fn-> make-box-box-rotation (collision-volume-box collision-volume-box) (values m3:mat m3:mat))
(defun make-box-box-rotation (box1 box2)
  (declare (optimize speed))
  (let* ((axes1 (collision-volume-box-axes box1))
         (axes2 (collision-volume-box-axes box2))
         (x1 (m3:get-column axes1 0))
         (y1 (m3:get-column axes1 1))
         (z1 (m3:get-column axes1 2))
         (x2 (m3:get-column axes2 0))
         (y2 (m3:get-column axes2 1))
         (z2 (m3:get-column axes2 2)))
    (declare (dynamic-extent x1 y1 z1 x2 y2 z2))
    (m3:with-components ((a (load-time-value (m3:id)))
                         (b (load-time-value (m3:id))))
      (setf a00 (v3:dot x1 x2)
            a10 (v3:dot y1 x2)
            a20 (v3:dot z1 x2)
            a01 (v3:dot x1 y2)
            a11 (v3:dot y1 y2)
            a21 (v3:dot z1 y2)
            a02 (v3:dot x1 z2)
            a12 (v3:dot y1 z1)
            a22 (v3:dot z1 z2)
            b00 (+ (abs a00) 1e-7)
            b10 (+ (abs a10) 1e-7)
            b20 (+ (abs a20) 1e-7)
            b01 (+ (abs a01) 1e-7)
            b11 (+ (abs a11) 1e-7)
            b21 (+ (abs a21) 1e-7)
            b02 (+ (abs a02) 1e-7)
            b12 (+ (abs a12) 1e-7)
            b22 (+ (abs a22) 1e-7))
      (values a b))))

(u:fn-> make-box-box-translation (collision-volume-box collision-volume-box) v3:vec)
(defun make-box-box-translation (box1 box2)
  (declare (optimize speed))
  (let* ((axes (collision-volume-box-axes box1))
         (x (m3:get-column axes 0))
         (y (m3:get-column axes 1))
         (z (m3:get-column axes 2))
         (translation (v3:- (collision-volume-world-center box2)
                            (collision-volume-world-center box1))))
    (declare (dynamic-extent x y z translation))
    (v3:vec (v3:dot translation x)
            (v3:dot translation y)
            (v3:dot translation z))))

(u:fn-> update-collision-volume-box (collision-volume-box trait) null)
(defun update-collision-volume-box (box collider)
  (declare (optimize speed))
  (let* ((owner (trait-owner collider))
         (center (collision-volume-center box))
         (min (transform-point owner (v3:+ center (collision-volume-box-min box))))
         (max (transform-point owner (v3:+ center (collision-volume-box-max box))))
         (world-center (v3:lerp! (collision-volume-world-center box) min max 0.5))
         (axes (m4:rotation-to-mat3 (m4:normalize-rotation (get-transform owner :space :world))))
         (diagonal (v3:- max world-center))
         (x (m3:get-column axes 0))
         (y (m3:get-column axes 1))
         (z (m3:get-column axes 2)))
    (declare (dynamic-extent x y z diagonal))
    (v3:with-components ((h (collision-volume-box-half-extents box)))
      (setf (collision-volume-world-center box) world-center
            (collision-volume-box-axes box) axes
            hx (v3:dot diagonal x)
            hy (v3:dot diagonal y)
            hz (v3:dot diagonal z))))
  nil)
