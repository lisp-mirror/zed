(in-package #:zed)

(defstruct (free-look-state
            (:constructor %make-free-look-state)
            (:predicate nil)
            (:copier nil))
  (camera-game-object nil :type game-object)
  (initial-state nil :type boolean)
  (initial-orientation (m4:id) :type m4:mat)
  (key-state (u:dict #'eq) :type hash-table)
  (key-speed 30.0 :type u:f32)
  (mouse-sensitivity 5.0 :type u:f32))

(u:fn-> make-free-look-state (game-object) free-look-state)
(defun make-free-look-state (camera)
  (declare (optimize speed))
  (%make-free-look-state :camera-game-object camera))

(u:fn-> set-initial-free-look-state (free-look-state m4:mat) null)
(defun set-initial-free-look-orientation (state model)
  (declare (optimize speed))
  (unless (free-look-state-initial-state state)
    (setf (free-look-state-initial-orientation state) model
          (free-look-state-initial-state state) t)
    nil))

(u:fn-> reset-free-look-state (free-look-state) null)
(defun reset-free-look-state (state)
  (declare (optimize speed))
  (let* ((model (free-look-state-initial-orientation state))
         (translation (m4:get-translation model))
         (rotation (q:from-mat4 model))
         (game-object (free-look-state-camera-game-object state)))
    (translate game-object translation :replace-p t)
    (rotate game-object rotation :replace-p t)
    nil))

(u:fn-> update-free-look-key-state (core free-look-state) null)
(defun update-free-look-key-state (core state)
  (declare (optimize speed))
  (let ((key-state (free-look-state-key-state state)))
    (when (on-button-enter core :key :backspace)
      (reset-free-look-state state))
    (cond
      ((on-button-enabled core :key :w)
       (setf (u:href key-state :forward) t))
      ((on-button-exit core :key :w)
       (setf (u:href key-state :forward) nil)))
    (cond
      ((on-button-enabled core :key :s)
       (setf (u:href key-state :backward) t))
      ((on-button-exit core :key :s)
       (setf (u:href key-state :backward) nil)))
    (cond
      ((on-button-enabled core :key :a)
       (setf (u:href key-state :strafe-left) t))
      ((on-button-exit core :key :a)
       (setf (u:href key-state :strafe-left) nil)))
    (cond
      ((on-button-enabled core :key :d)
       (setf (u:href key-state :strafe-right) t))
      ((on-button-exit core :key :d)
       (setf (u:href key-state :strafe-right) nil)))
    (cond
      ((on-button-enabled core :key :left)
       (setf (u:href key-state :turn-left) t))
      ((on-button-exit core :key :left)
       (setf (u:href key-state :turn-left) nil)))
    (cond
      ((on-button-enabled core :key :right)
       (setf (u:href key-state :turn-right) t))
      ((on-button-exit core :key :right)
       (setf (u:href key-state :turn-right) nil)))
    (cond
      ((on-button-enabled core :key :pageup)
       (setf (u:href key-state :strafe-up) t))
      ((on-button-exit core :key :pageup)
       (setf (u:href key-state :strafe-up) nil)))
    (cond
      ((on-button-enabled core :key :pagedown)
       (setf (u:href key-state :strafe-down) t))
      ((on-button-exit core :key :pagedown)
       (setf (u:href key-state :strafe-down) nil)))
    nil))

(u:fn-> free-look/key-move (game-object hash-table u:f32) null)
(defun free-look/key-move (camera key-state speed)
  (declare (optimize speed))
  (flet ((velocity (direction plus minus)
           (v3:scale (transform-direction camera direction)
                     (cond
                       ((u:href key-state plus) speed)
                       ((u:href key-state minus) (- speed))
                       (t 0.0)))))
    (let* ((x (velocity v3:+right+ :strafe-right :strafe-left))
           (y (velocity v3:+up+ :strafe-up :strafe-down))
           (z (velocity v3:+back+ :forward :backward))
           (vec (v3:+ (v3:+ x y) z))
           (angle (velocity v3:+up+ :turn-left :turn-right)))
      (translate camera vec)
      (rotate/velocity camera angle 1.0)
      nil)))

(u:fn-> free-look/mouse-move (core game-object u:f32) null)
(defun free-look/mouse-move (core camera speed)
  (declare (optimize speed))
  (flet ((velocity (direction x)
           (v3:scale (transform-direction camera direction) (* x speed))))
    (u:mvlet* ((mx my dx dy (get-mouse-position core))
               (x (velocity v3:+right+ dx))
               (y (velocity v3:+up+ dy))
               (z (velocity v3:+forward+ dy))
               (vec (v3:+ x y))
               (angle (v3:+ (velocity v3:+down+ dx) (velocity v3:+right+ dy))))
      (when (or (on-button-enter core :key :lshift)
                (on-button-enter core :key :lalt)
                (on-button-enter core :key :lctrl))
        (enable-relative-mouse-mode core))
      (when (on-button-enabled core :key :lshift)
        (translate camera vec))
      (when (on-button-enabled core :key :lalt)
        (translate camera z))
      (when (on-button-enabled core :key :lctrl)
        (rotate/velocity camera angle 1.0))
      (when (or (on-button-exit core :key :lshift)
                (on-button-exit core :key :lalt)
                (on-button-exit core :key :lctrl))
        (disable-relative-mouse-mode core))
      nil)))

(u:fn-> update-free-look-state (core free-look-state) null)
(defun update-free-look-state (core state)
  (declare (optimize speed))
  (u:mvlet* ((camera (free-look-state-camera-game-object state))
             (clock (core-clock core))
             (frame-time (get-frame-time clock))
             (key-speed (* (free-look-state-key-speed state) frame-time))
             (mouse-speed (* (free-look-state-mouse-sensitivity state) frame-time)))
    (update-free-look-key-state core state)
    (free-look/key-move camera (free-look-state-key-state state) key-speed)
    (free-look/mouse-move core camera mouse-speed)
    nil))
